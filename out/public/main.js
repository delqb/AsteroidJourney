(() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };

  // ../FluidEngine/dist/api/core/archetype/Archetype.js
  var init_Archetype = __esm({
    "../FluidEngine/dist/api/core/archetype/Archetype.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/component/Component.js
  var init_Component = __esm({
    "../FluidEngine/dist/api/core/component/Component.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/component/ComponentFactory.js
  var init_ComponentFactory = __esm({
    "../FluidEngine/dist/api/core/component/ComponentFactory.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/component/ComponentManager.js
  var init_ComponentManager = __esm({
    "../FluidEngine/dist/api/core/component/ComponentManager.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/component/ComponentRepository.js
  var init_ComponentRepository = __esm({
    "../FluidEngine/dist/api/core/component/ComponentRepository.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/component/ComponentRepositoryHook.js
  var init_ComponentRepositoryHook = __esm({
    "../FluidEngine/dist/api/core/component/ComponentRepositoryHook.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/component/type/ComponentType.js
  var init_ComponentType = __esm({
    "../FluidEngine/dist/api/core/component/type/ComponentType.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/component/type/ComponentTypeId.js
  var init_ComponentTypeId = __esm({
    "../FluidEngine/dist/api/core/component/type/ComponentTypeId.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/component/type/ComponentTypeFactory.js
  var init_ComponentTypeFactory = __esm({
    "../FluidEngine/dist/api/core/component/type/ComponentTypeFactory.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/component/type/ComponentTypeRegistry.js
  var init_ComponentTypeRegistry = __esm({
    "../FluidEngine/dist/api/core/component/type/ComponentTypeRegistry.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/component/type/ComponentTypeRegistryHook.js
  var init_ComponentTypeRegistryHook = __esm({
    "../FluidEngine/dist/api/core/component/type/ComponentTypeRegistryHook.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/component/type/ComponentTypeResolver.js
  var init_ComponentTypeResolver = __esm({
    "../FluidEngine/dist/api/core/component/type/ComponentTypeResolver.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/component/index.js
  var init_component = __esm({
    "../FluidEngine/dist/api/core/component/index.js"() {
      init_Component();
      init_ComponentFactory();
      init_ComponentManager();
      init_ComponentRepository();
      init_ComponentRepositoryHook();
      init_ComponentType();
      init_ComponentTypeId();
      init_ComponentTypeFactory();
      init_ComponentTypeRegistry();
      init_ComponentTypeRegistryHook();
      init_ComponentTypeResolver();
    }
  });

  // ../FluidEngine/dist/api/core/entity/EntityArchetypeHook.js
  var init_EntityArchetypeHook = __esm({
    "../FluidEngine/dist/api/core/entity/EntityArchetypeHook.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/entity/EntityArchetypeResolver.js
  var init_EntityArchetypeResolver = __esm({
    "../FluidEngine/dist/api/core/entity/EntityArchetypeResolver.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/entity/EntityComponentProvider.js
  var init_EntityComponentProvider = __esm({
    "../FluidEngine/dist/api/core/entity/EntityComponentProvider.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/entity/EntityComponentTypesProvider.js
  var init_EntityComponentTypesProvider = __esm({
    "../FluidEngine/dist/api/core/entity/EntityComponentTypesProvider.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/entity/EntityFactory.js
  var init_EntityFactory = __esm({
    "../FluidEngine/dist/api/core/entity/EntityFactory.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/entity/EntityId.js
  var init_EntityId = __esm({
    "../FluidEngine/dist/api/core/entity/EntityId.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/entity/EntityManager.js
  var init_EntityManager = __esm({
    "../FluidEngine/dist/api/core/entity/EntityManager.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/entity/EntityProxy.js
  var init_EntityProxy = __esm({
    "../FluidEngine/dist/api/core/entity/EntityProxy.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/entity/EntityProxyFactory.js
  var init_EntityProxyFactory = __esm({
    "../FluidEngine/dist/api/core/entity/EntityProxyFactory.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/entity/EntityResolver.js
  var init_EntityResolver = __esm({
    "../FluidEngine/dist/api/core/entity/EntityResolver.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/entity/index.js
  var init_entity = __esm({
    "../FluidEngine/dist/api/core/entity/index.js"() {
      init_EntityArchetypeHook();
      init_EntityArchetypeResolver();
      init_EntityComponentProvider();
      init_EntityComponentTypesProvider();
      init_EntityFactory();
      init_EntityId();
      init_EntityManager();
      init_EntityProxy();
      init_EntityProxyFactory();
      init_EntityResolver();
    }
  });

  // ../FluidEngine/dist/api/core/node/Node.js
  var init_Node = __esm({
    "../FluidEngine/dist/api/core/node/Node.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/node/NodeFactory.js
  var init_NodeFactory = __esm({
    "../FluidEngine/dist/api/core/node/NodeFactory.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/node/NodeIndex.js
  var init_NodeIndex = __esm({
    "../FluidEngine/dist/api/core/node/NodeIndex.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/node/NodeManager.js
  var init_NodeManager = __esm({
    "../FluidEngine/dist/api/core/node/NodeManager.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/node/NodeRepository.js
  var init_NodeRepository = __esm({
    "../FluidEngine/dist/api/core/node/NodeRepository.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/node/schema/NodeSchema.js
  var init_NodeSchema = __esm({
    "../FluidEngine/dist/api/core/node/schema/NodeSchema.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/node/schema/NodeSchemaArchetypeHook.js
  var init_NodeSchemaArchetypeHook = __esm({
    "../FluidEngine/dist/api/core/node/schema/NodeSchemaArchetypeHook.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/node/schema/NodeSchemaArchetypeProvider.js
  var init_NodeSchemaArchetypeProvider = __esm({
    "../FluidEngine/dist/api/core/node/schema/NodeSchemaArchetypeProvider.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/node/schema/NodeSchemaId.js
  var init_NodeSchemaId = __esm({
    "../FluidEngine/dist/api/core/node/schema/NodeSchemaId.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/node/schema/NodeSchemaIndex.js
  var init_NodeSchemaIndex = __esm({
    "../FluidEngine/dist/api/core/node/schema/NodeSchemaIndex.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/node/schema/NodeSchemaMeta.js
  var init_NodeSchemaMeta = __esm({
    "../FluidEngine/dist/api/core/node/schema/NodeSchemaMeta.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/node/schema/NodeSchemaRegistry.js
  var init_NodeSchemaRegistry = __esm({
    "../FluidEngine/dist/api/core/node/schema/NodeSchemaRegistry.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/node/schema/NodeSchemaRegistryHook.js
  var init_NodeSchemaRegistryHook = __esm({
    "../FluidEngine/dist/api/core/node/schema/NodeSchemaRegistryHook.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/node/schema/NodeSchemaResolver.js
  var init_NodeSchemaResolver = __esm({
    "../FluidEngine/dist/api/core/node/schema/NodeSchemaResolver.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/node/index.js
  var init_node = __esm({
    "../FluidEngine/dist/api/core/node/index.js"() {
      init_Node();
      init_NodeFactory();
      init_NodeIndex();
      init_NodeManager();
      init_NodeRepository();
      init_NodeSchema();
      init_NodeSchemaArchetypeHook();
      init_NodeSchemaArchetypeProvider();
      init_NodeSchemaId();
      init_NodeSchemaIndex();
      init_NodeSchemaMeta();
      init_NodeSchemaRegistry();
      init_NodeSchemaRegistryHook();
      init_NodeSchemaResolver();
    }
  });

  // ../FluidEngine/dist/api/core/system/System.js
  var init_System = __esm({
    "../FluidEngine/dist/api/core/system/System.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/system/SystemMeta.js
  var init_SystemMeta = __esm({
    "../FluidEngine/dist/api/core/system/SystemMeta.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/system/SystemOrchestrator.js
  var init_SystemOrchestrator = __esm({
    "../FluidEngine/dist/api/core/system/SystemOrchestrator.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/system/SystemPhase.js
  var init_SystemPhase = __esm({
    "../FluidEngine/dist/api/core/system/SystemPhase.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/system/index.js
  var init_system = __esm({
    "../FluidEngine/dist/api/core/system/index.js"() {
      init_System();
      init_SystemMeta();
      init_SystemOrchestrator();
      init_SystemPhase();
    }
  });

  // ../FluidEngine/dist/api/core/util/OrderedList.js
  var init_OrderedList = __esm({
    "../FluidEngine/dist/api/core/util/OrderedList.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/util/hook/HookDispatcher.js
  var init_HookDispatcher = __esm({
    "../FluidEngine/dist/api/core/util/hook/HookDispatcher.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/util/index.js
  var init_util = __esm({
    "../FluidEngine/dist/api/core/util/index.js"() {
      init_OrderedList();
      init_HookDispatcher();
    }
  });

  // ../FluidEngine/dist/api/core/Core.js
  var init_Core = __esm({
    "../FluidEngine/dist/api/core/Core.js"() {
    }
  });

  // ../FluidEngine/dist/api/core/CoreRuntime.js
  var CoreRuntime;
  var init_CoreRuntime = __esm({
    "../FluidEngine/dist/api/core/CoreRuntime.js"() {
      CoreRuntime = class _CoreRuntime {
        static __instance = null;
        static initialize(instance) {
          if (_CoreRuntime.__instance) {
            throw new Error("Core is already initialized.");
          }
          _CoreRuntime.__instance = instance;
        }
        static getInstance() {
          if (!_CoreRuntime.__instance) {
            throw new Error("Core is not initialized.");
          }
          return _CoreRuntime.__instance;
        }
        static nullifyInstance() {
          if (!_CoreRuntime.__instance) {
            throw new Error("Core is not initialized; instance is already nullified.");
          }
          _CoreRuntime.__instance = null;
        }
      };
    }
  });

  // ../FluidEngine/dist/api/core/index.js
  var init_core = __esm({
    "../FluidEngine/dist/api/core/index.js"() {
      init_Archetype();
      init_component();
      init_entity();
      init_node();
      init_system();
      init_util();
      init_Core();
      init_CoreRuntime();
    }
  });

  // ../FluidEngine/dist/api/FluidAPI.js
  var init_FluidAPI = __esm({
    "../FluidEngine/dist/api/FluidAPI.js"() {
    }
  });

  // ../FluidEngine/dist/api/index.js
  var init_api = __esm({
    "../FluidEngine/dist/api/index.js"() {
      init_core();
      init_FluidAPI();
    }
  });

  // ../FluidEngine/dist/lib/geometry/AABB.js
  function aabbsIntersect(a, b) {
    return a.minX <= b.maxX && a.maxX >= b.minX && a.maxY >= b.minY && a.minY <= b.maxY;
  }
  var init_AABB = __esm({
    "../FluidEngine/dist/lib/geometry/AABB.js"() {
    }
  });

  // ../FluidEngine/dist/lib/geometry/ConvexPolygon.js
  function isSeparatingAxisExistent(polygonA, polygonB, quantization_precision = 1e6) {
    const seen = /* @__PURE__ */ new Set();
    for (const vertices of [polygonA, polygonB]) {
      for (let i = 0; i < vertices.length; i++) {
        const current = vertices[i];
        const next = vertices[(i + 1) % vertices.length];
        const edgeX = next.x - current.x, edgeY = next.y - current.y;
        const edgeLength = Math.hypot(edgeX, edgeY);
        const unitNormX = -edgeY / edgeLength, unitNormY = edgeX / edgeLength;
        const dot = unitNormX * reference_axis.x + unitNormY * reference_axis.y;
        const quantized = Math.round(Math.abs(dot) * quantization_precision);
        if (seen.has(quantized))
          continue;
        seen.add(quantized);
        const [minA, maxA] = projectPolygonOntoAxis(polygonA, unitNormX, unitNormY);
        const [minB, maxB] = projectPolygonOntoAxis(polygonB, unitNormX, unitNormY);
        if (maxA < minB || maxB < minA) {
          return true;
        }
      }
    }
    return false;
  }
  function projectPolygonOntoAxis(polygon, axisX, axisY) {
    let min = Infinity, max = -Infinity;
    for (const v of polygon) {
      const proj = v.x * axisX + v.y * axisY;
      if (proj < min)
        min = proj;
      if (proj > max)
        max = proj;
    }
    return [min, max];
  }
  var reference_axis;
  var init_ConvexPolygon = __esm({
    "../FluidEngine/dist/lib/geometry/ConvexPolygon.js"() {
      reference_axis = { x: Math.SQRT1_2, y: Math.SQRT1_2 };
    }
  });

  // ../FluidEngine/dist/lib/geometry/Vector2.js
  var Vector2;
  var init_Vector2 = __esm({
    "../FluidEngine/dist/lib/geometry/Vector2.js"() {
      Vector2 = {
        zero: () => {
          return { x: 0, y: 0 };
        },
        create: (x = 0, y = 0) => ({ x, y }),
        add: (a, b) => ({ x: a.x + b.x, y: a.y + b.y }),
        subtract: (a, b) => ({ x: a.x - b.x, y: a.y - b.y }),
        multiply: (a, b) => ({ x: a.x * b.x, y: a.y * b.y }),
        divide: (a, b) => ({ x: a.x / b.x, y: a.y / b.y }),
        scale: (v, scalar) => ({ x: v.x * scalar, y: v.y * scalar }),
        dot: (a, b) => a.x * b.x + a.y * b.y,
        abs: (v) => ({ x: Math.abs(v.x), y: Math.abs(v.y) }),
        magnitude: (v) => Math.sqrt(v.x * v.x + v.y * v.y),
        normalize: (v) => {
          const mag = Vector2.magnitude(v);
          return mag === 0 ? { x: 0, y: 0 } : { x: v.x / mag, y: v.y / mag };
        },
        distanceSquared: (a, b) => (a.x - b.x) ** 2 + (a.y - b.y) ** 2,
        distance: (a, b) => Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2),
        // the clockwise, radian angle between the positive x axis with vector 'a' as the origin and the line from vector 'a' to vector 'b'
        angle: (a, b) => {
          let diff = Vector2.subtract(b, a);
          return Math.atan2(diff.y, diff.x);
        },
        fromAngle: (t) => ({ x: Math.cos(t), y: Math.sin(t) }),
        copy: (v) => {
          return { x: v.x, y: v.y };
        }
      };
    }
  });

  // ../FluidEngine/dist/lib/geometry/OBB.js
  function createOBB({ halfExtents = Vector2.zero(), axes = { x: Vector2.zero(), y: Vector2.zero() }, corners = [Vector2.zero(), Vector2.zero(), Vector2.zero(), Vector2.zero()] } = {}) {
    return { halfExtents, axes, corners };
  }
  var init_OBB = __esm({
    "../FluidEngine/dist/lib/geometry/OBB.js"() {
      init_Vector2();
    }
  });

  // ../FluidEngine/dist/lib/geometry/RectSize.js
  var init_RectSize = __esm({
    "../FluidEngine/dist/lib/geometry/RectSize.js"() {
    }
  });

  // ../FluidEngine/dist/lib/geometry/Transform.js
  function createTransform({ translate = void 0, rotate = void 0, scale = void 0 } = {}) {
    return { translate, scale, rotate };
  }
  var init_Transform = __esm({
    "../FluidEngine/dist/lib/geometry/Transform.js"() {
    }
  });

  // ../FluidEngine/dist/lib/geometry/index.js
  var init_geometry = __esm({
    "../FluidEngine/dist/lib/geometry/index.js"() {
      init_AABB();
      init_ConvexPolygon();
      init_OBB();
      init_RectSize();
      init_Transform();
      init_Vector2();
    }
  });

  // ../FluidEngine/dist/lib/structures/OrderedArrayList.js
  var OrderedArrayList;
  var init_OrderedArrayList = __esm({
    "../FluidEngine/dist/lib/structures/OrderedArrayList.js"() {
      OrderedArrayList = class {
        compareFn;
        items = [];
        itemSet = /* @__PURE__ */ new Set();
        constructor(initialItems = [], compareFn = (a, b) => a - b) {
          this.compareFn = compareFn;
          this.items = initialItems.slice().sort((a, b) => this.compareFn(a.order, b.order));
        }
        getItemList() {
          return this.items;
        }
        insertItem(entry) {
          const index = this.findInsertionIndex(entry.order);
          this.items.splice(index, 0, entry);
          this.itemSet.add(entry.item);
        }
        // Insert with binary search to maintain order
        insert(item, order) {
          this.insertItem({ item, order });
        }
        has(value) {
          return this.itemSet.has(value);
        }
        // Binary search for insertion point
        findInsertionIndex(order) {
          let left = 0, right = this.items.length;
          while (left < right) {
            const mid = left + right >>> 1;
            if (this.items[mid].order > order) {
              right = mid;
            } else {
              left = mid + 1;
            }
          }
          return left;
        }
        // Access all in priority order
        getAll() {
          return this.items.map((o) => o.item);
        }
        // Fast lookup by index
        get(index) {
          return this.items[index]?.item;
        }
        remove(value) {
          if (!this.itemSet.has(value))
            return;
          const index = this.items.findIndex((o) => Object.is(o.item, value));
          if (index !== -1)
            this.items.splice(index, 1);
        }
        getSize() {
          return this.items.length;
        }
        clear() {
          this.items.length = 0;
        }
        at(index) {
          return this.items[index];
        }
        entries() {
          return this.items.values();
        }
      };
    }
  });

  // ../FluidEngine/dist/lib/utils/FPSTimer.js
  var FPSTimer;
  var init_FPSTimer = __esm({
    "../FluidEngine/dist/lib/utils/FPSTimer.js"() {
      FPSTimer = class {
        FRAME_SAMPLING_INTERVAL;
        previousSampleTimestamp = 0;
        frameCountSinceSample = 0;
        currentFPS = 0;
        constructor(FRAME_SAMPLING_INTERVAL = 20) {
          this.FRAME_SAMPLING_INTERVAL = FRAME_SAMPLING_INTERVAL;
        }
        tick() {
          this.frameCountSinceSample++;
          if (this.frameCountSinceSample < this.FRAME_SAMPLING_INTERVAL)
            return;
          const now = performance.now(), elapsed = now - this.previousSampleTimestamp;
          if (this.previousSampleTimestamp && elapsed > 0)
            this.currentFPS = this.FRAME_SAMPLING_INTERVAL * 1e3 / elapsed;
          this.previousSampleTimestamp = now;
          this.frameCountSinceSample = 0;
        }
        getFPS() {
          return this.currentFPS;
        }
      };
    }
  });

  // ../FluidEngine/dist/lib/utils/MathUtils.js
  var MathUtils_exports = {};
  __export(MathUtils_exports, {
    PI: () => PI,
    PI2: () => PI2,
    boundedRandom: () => boundedRandom,
    encodeIntegerPair: () => encodeIntegerPair,
    hPI: () => hPI,
    lerp: () => lerp,
    round: () => round,
    shortestAngleDiff: () => shortestAngleDiff
  });
  function shortestAngleDiff(a, b) {
    let diff = (b - a) % PI2;
    if (diff > Math.PI)
      diff -= PI2;
    if (diff < -Math.PI)
      diff += PI2;
    return diff;
  }
  function round(num, decimalPlaces = 3) {
    return Math.round(num * 10 ** decimalPlaces) / 10 ** decimalPlaces;
  }
  function lerp(start2, end, t) {
    return start2 + (end - start2) * t;
  }
  function boundedRandom(min, max) {
    return min + (max - min) * Math.random();
  }
  function encodeIntegerPair(x, y) {
    const X = x >= 0 ? 2 * x : -2 * x - 1;
    const Y = y >= 0 ? 2 * y : -2 * y - 1;
    return X >= Y ? X * X + X + Y : Y * Y + X;
  }
  var PI, PI2, hPI;
  var init_MathUtils = __esm({
    "../FluidEngine/dist/lib/utils/MathUtils.js"() {
      PI = Math.PI;
      PI2 = PI * 2;
      hPI = PI / 2;
    }
  });

  // ../FluidEngine/dist/lib/utils/GridUtils.js
  var GridUtils_exports = {};
  __export(GridUtils_exports, {
    conservativeOBBRasterization: () => conservativeOBBRasterization
  });
  function conservativeOBBRasterization(rectWidth, rectHeight, cellSize, widthProjectionFactor, heightProjectionFactor, axes, center, scanResolution, collect) {
    if (rectWidth <= 0 || rectHeight <= 0 || cellSize <= 0)
      throw new Error(`Invalid grid scan parameters: found zero or negative values.`);
    const rw = rectWidth * widthProjectionFactor, rh = rectHeight * heightProjectionFactor;
    const hw2 = rw / 2, hh2 = rh / 2;
    const nXStep = ceil(rw / cellSize) * scanResolution, nYStep = ceil(rh / cellSize) * scanResolution;
    const xStep = rw / nXStep, yStep = rh / nYStep;
    const cx = center.x, cy = center.y;
    const ax = axes.x, ay = axes.y;
    const axx = ax.x, axy = ax.y, ayx = ay.x, ayy = ay.y;
    const seen = /* @__PURE__ */ new Set();
    for (let i = 0; i <= nXStep; i++) {
      for (let j = 0; j <= nYStep; j++) {
        const lx = -hw2 + i * xStep, ly = -hh2 + j * yStep;
        const x = cx + lx * axx + ly * ayx, y = cy + lx * axy + ly * ayy;
        const cellIdxX = floor(x / cellSize), cellIdxY = floor(y / cellSize);
        const enc = encodeIntegerPair(cellIdxX, cellIdxY);
        if (seen.has(enc))
          continue;
        seen.add(enc);
        collect(cellIdxX, cellIdxY);
      }
    }
  }
  var ceil, floor;
  var init_GridUtils = __esm({
    "../FluidEngine/dist/lib/utils/GridUtils.js"() {
      init_MathUtils();
      ceil = Math.ceil;
      floor = Math.floor;
    }
  });

  // ../FluidEngine/dist/lib/utils/ImageUtils.js
  var ImageUtils_exports = {};
  __export(ImageUtils_exports, {
    canvasToImage: () => canvasToImage,
    loadImage: () => loadImage
  });
  function loadImage(src, timeoutMs = 1e4) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      const timer = setTimeout(() => {
        img.src = "";
        reject(new Error(`Timeout while loading image: "${src}"`));
      }, timeoutMs);
      img.onload = () => {
        clearTimeout(timer);
        resolve(img);
      };
      img.onerror = (event) => {
        clearTimeout(timer);
        const error = new Error(`Failed to load image: '${src}'`);
        console.error(event);
        error.event = event;
        error.src = src;
        reject(error);
      };
      img.src = src;
    });
  }
  function canvasToImage(canvas, imageObject) {
    const imageDataUrl = canvas.toDataURL();
    const image = imageObject || new Image();
    image.src = imageDataUrl;
    return image;
  }
  var init_ImageUtils = __esm({
    "../FluidEngine/dist/lib/utils/ImageUtils.js"() {
    }
  });

  // ../FluidEngine/dist/lib/utils/LazyIterableMap.js
  function* getLazyMappedIterable(source, map) {
    for (const item of source) {
      yield map(item);
    }
  }
  var init_LazyIterableMap = __esm({
    "../FluidEngine/dist/lib/utils/LazyIterableMap.js"() {
    }
  });

  // ../FluidEngine/dist/lib/utils/index.js
  var init_utils = __esm({
    "../FluidEngine/dist/lib/utils/index.js"() {
      init_FPSTimer();
      init_GridUtils();
      init_ImageUtils();
      init_LazyIterableMap();
      init_MathUtils();
    }
  });

  // ../FluidEngine/dist/lib/world/chunk/Chunk.js
  function isChunkState(value) {
    return value === ChunkState.Loaded || value === ChunkState.Unloaded;
  }
  function createChunk(indexOrKey, size, state, { lastAccessed = 0, entitySymbolSet = /* @__PURE__ */ new Set() } = {}) {
    let key;
    let index;
    if (typeof indexOrKey === "string") {
      index = parseChunkKey(indexOrKey);
      key = indexOrKey;
    } else if (Array.isArray(indexOrKey) && indexOrKey.length === 2 && typeof indexOrKey[0] === "number" && typeof indexOrKey[1] === "number") {
      index = indexOrKey;
      key = getChunkKeyFromIndex(indexOrKey[0], indexOrKey[1]);
    } else {
      throw new Error(`Invalid chunk parameters: expected chunk index [i,j] or key "i,j".
	Received value: ${JSON.stringify(indexOrKey)}`);
    }
    if (!isChunkState(state)) {
      throw new Error(`Invalid chunk parameters: expected chunk state ('${ChunkState.Loaded}' or '${ChunkState.Unloaded}')
	Received value:${state}`);
    }
    return {
      index,
      key,
      state,
      lastAccessed,
      entitySymbolSet,
      size
    };
  }
  function getChunkIndexFromPosition(pos, chunkSize) {
    return [floor2(pos.x / chunkSize), floor2(pos.y / chunkSize)];
  }
  function getChunkCornerFromIndex(i, j, chunkSize) {
    return { x: i * chunkSize, y: j * chunkSize };
  }
  function getChunkCenterFromIndex(i, j, chunkSize) {
    return { x: (i + 0.5) * chunkSize, y: (j + 0.5) * chunkSize };
  }
  function parseChunkKey(key, silent = false) {
    if (typeof key !== "string") {
      if (silent)
        return void 0;
      throw new Error(`Invalid chunk key: expected a type of "string"
	type:${typeof key}`);
    }
    const parts = key.split(",");
    if (parts.length !== 2) {
      if (silent)
        return void 0;
      throw new Error(`Invalid chunk key format: expected "x,y"
	value:"${key}"`);
    }
    const i = parseInt(parts[0], 10);
    const j = parseInt(parts[1], 10);
    if (isNaN(i) || isNaN(j)) {
      if (silent)
        return void 0;
      throw new Error(`Invalid chunk key indices: "${key}" does not contain valid integers`);
    }
    return [i, j];
  }
  function getChunkKeyFromIndex(i, j) {
    return `${i},${j}`;
  }
  var floor2, ChunkState;
  var init_Chunk = __esm({
    "../FluidEngine/dist/lib/world/chunk/Chunk.js"() {
      floor2 = Math.floor;
      (function(ChunkState2) {
        ChunkState2[ChunkState2["Loaded"] = 1] = "Loaded";
        ChunkState2[ChunkState2["Unloaded"] = 2] = "Unloaded";
      })(ChunkState || (ChunkState = {}));
    }
  });

  // ../FluidEngine/dist/lib/index.js
  var init_lib = __esm({
    "../FluidEngine/dist/lib/index.js"() {
      init_geometry();
      init_OrderedArrayList();
      init_utils();
      init_Chunk();
    }
  });

  // ../FluidEngine/dist/internal/FluidEngine.js
  var FluidEngine;
  var init_FluidEngine = __esm({
    "../FluidEngine/dist/internal/FluidEngine.js"() {
      init_dist();
      FluidEngine = class {
        core;
        PIXELS_PER_METER;
        deltaTime;
        isAnimating = false;
        gameTime = 0;
        fpsTimer;
        constructor(core, PIXELS_PER_METER = 1e3, deltaTime = 1 / 60, FPS_SAMPLING_INTERVAL = 20) {
          this.core = core;
          this.PIXELS_PER_METER = PIXELS_PER_METER;
          this.deltaTime = deltaTime;
          this.fpsTimer = new FPSTimer(FPS_SAMPLING_INTERVAL);
        }
        getFPS() {
          return this.fpsTimer.getFPS();
        }
        getGameTime() {
          return this.gameTime;
        }
        getDeltaTime() {
          return this.deltaTime;
        }
        animate() {
          try {
            this.fpsTimer.tick();
            this.core.update();
          } catch (err) {
            console.error(err);
          }
          if (this.isAnimating)
            requestAnimationFrame(this.animate.bind(this));
          this.gameTime += this.deltaTime;
        }
        getAnimationState() {
          return this.isAnimating;
        }
        startAnimation() {
          if (this.isAnimating)
            return;
          this.isAnimating = true;
          this.animate();
        }
        stopAnimation() {
          this.isAnimating = false;
        }
        toggleAnimation() {
          if (this.isAnimating)
            this.stopAnimation();
          else
            this.startAnimation();
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/archetype/FluidArchetype.js
  var FluidArchetype;
  var init_FluidArchetype = __esm({
    "../FluidEngine/dist/internal/core/archetype/FluidArchetype.js"() {
      FluidArchetype = class _FluidArchetype {
        bitSet;
        constructor(bitSet = 0n) {
          this.bitSet = bitSet;
        }
        static validateNumericId(numId) {
          if (numId < 0 || numId > 1023) {
            throw new RangeError(`Component ID ${numId} is out of supported bitmask bounds.`);
          }
          return numId;
        }
        static getBitPosition(componentType) {
          return BigInt(_FluidArchetype.validateNumericId(componentType.getId().getNumericId()));
        }
        static getBitMask(componentType) {
          return 1n << _FluidArchetype.getBitPosition(componentType);
        }
        static computeArchetypeBitSet(componentTypes) {
          let bitSet = 0n;
          for (const componentType of componentTypes) {
            bitSet |= _FluidArchetype.getBitMask(componentType);
          }
          return bitSet;
        }
        getBitSet() {
          return this.bitSet;
        }
        has(componentType) {
          return (this.bitSet & _FluidArchetype.getBitMask(componentType)) !== 0n;
        }
        equals(other) {
          return other instanceof _FluidArchetype && other.bitSet === this.bitSet;
        }
        isSuperSetOf(other) {
          return other instanceof _FluidArchetype && (this.bitSet & other.bitSet) === other.bitSet;
        }
        with(componentType) {
          return new _FluidArchetype(this.bitSet | _FluidArchetype.getBitMask(componentType));
        }
        without(componentType) {
          return new _FluidArchetype(this.bitSet & ~_FluidArchetype.getBitMask(componentType));
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/archetype/FluidArchetypeRegistry.js
  var FluidArchetypeRegistry;
  var init_FluidArchetypeRegistry = __esm({
    "../FluidEngine/dist/internal/core/archetype/FluidArchetypeRegistry.js"() {
      init_FluidArchetype();
      FluidArchetypeRegistry = class {
        map = /* @__PURE__ */ new Map();
        has(bitSet) {
          return this.map.has(bitSet);
        }
        get(bitSet) {
          if (!this.map.has(bitSet)) {
            throw new Error(`Could not retrieve archetype with bitset '${bitSet.toString()}'. Not found.`);
          }
          return this.map.get(bitSet);
        }
        getOrCreate(bitSet) {
          let archetype = this.map.get(bitSet);
          if (!archetype) {
            archetype = new FluidArchetype(bitSet);
            this.map.set(bitSet, archetype);
          }
          return archetype;
        }
        add(archetype) {
          this.map.set(archetype.getBitSet(), archetype);
        }
        remove(bitSet) {
          if (!this.map.delete(bitSet)) {
            throw new Error(`Could not remove archetype with bitset '${bitSet.toString()}'. Not found.`);
          }
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/component/FluidComponent.js
  var FluidComponent;
  var init_FluidComponent = __esm({
    "../FluidEngine/dist/internal/core/component/FluidComponent.js"() {
      FluidComponent = class {
        componentTypeId;
        data;
        constructor(componentTypeId, data) {
          this.componentTypeId = componentTypeId;
          this.data = data;
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/component/FluidComponentFactory.js
  var FluidComponentFactory;
  var init_FluidComponentFactory = __esm({
    "../FluidEngine/dist/internal/core/component/FluidComponentFactory.js"() {
      init_FluidComponent();
      FluidComponentFactory = class {
        createComponent(componentType, componentData, copyData) {
          return new FluidComponent(componentType.getId(), copyData ? { ...componentData } : componentData);
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/component/FluidComponentManager.js
  var FluidComponentManager;
  var init_FluidComponentManager = __esm({
    "../FluidEngine/dist/internal/core/component/FluidComponentManager.js"() {
      FluidComponentManager = class {
        componentTypeFactory;
        componentTypeRegistry;
        componentTypeResolver;
        componentFactory;
        componentRepository;
        constructor(componentTypeFactory, componentTypeRegistry, componentTypeResolver, componentFactory, componentRepository) {
          this.componentTypeFactory = componentTypeFactory;
          this.componentTypeRegistry = componentTypeRegistry;
          this.componentTypeResolver = componentTypeResolver;
          this.componentFactory = componentFactory;
          this.componentRepository = componentRepository;
        }
        getComponentTypeResolver() {
          return this.componentTypeResolver;
        }
        getComponentTypeFactory() {
          return this.componentTypeFactory;
        }
        getComponentTypeRegistry() {
          return this.componentTypeRegistry;
        }
        getComponentFactory() {
          return this.componentFactory;
        }
        getComponentRepository() {
          return this.componentRepository;
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/component/FluidComponentRepository.js
  var FluidComponentRepository;
  var init_FluidComponentRepository = __esm({
    "../FluidEngine/dist/internal/core/component/FluidComponentRepository.js"() {
      FluidComponentRepository = class _FluidComponentRepository {
        getComponentType;
        hooks;
        static EMPTY_COMPONENT_TYPES = Object.freeze([]);
        // Maps component type symbol -> (entity symbol -> component)
        componentTypeToComponentMap = /* @__PURE__ */ new Map();
        // Maps entity symbol -> (component type symbol -> component type)
        entityToComponentTypesMap = /* @__PURE__ */ new Map();
        constructor(getComponentType, hooks) {
          this.getComponentType = getComponentType;
          this.hooks = hooks;
        }
        getEntityComponentMap(componentType) {
          const typeId = componentType.getId();
          const typeSymbol = typeId.getSymbol();
          const typeName = typeId.getName();
          const componentMap = this.componentTypeToComponentMap.get(typeSymbol);
          if (!componentMap) {
            throw new Error(`Could not find component with type '${typeName}' in repository: the component type key was not found in map.`);
          }
          return componentMap;
        }
        withComponentEntry(componentType, entityId, operation) {
          const entitySymbol = entityId.getSymbol();
          const typeName = componentType.getId().getName();
          const componentMap = this.getEntityComponentMap(componentType);
          const component = componentMap.get(entitySymbol);
          if (!component) {
            throw new Error(`Could not find a component with type '${typeName}' from repository: entity '${entityId.toString()}' is not associated with a component of this type.`);
          }
          return operation(componentMap, entitySymbol);
        }
        removeComponentType(typeSymbol, entitySymbol) {
          const typesMap = this.entityToComponentTypesMap.get(entitySymbol);
          if (typesMap) {
            typesMap.delete(typeSymbol);
            if (typesMap.size === 0) {
              this.entityToComponentTypesMap.delete(entitySymbol);
            }
          }
        }
        addComponentType(componentType, entitySymbol) {
          const typeSymbol = componentType.getId().getSymbol();
          let componentTypesMap = this.entityToComponentTypesMap.get(entitySymbol);
          if (!componentTypesMap) {
            componentTypesMap = /* @__PURE__ */ new Map();
            this.entityToComponentTypesMap.set(entitySymbol, componentTypesMap);
          }
          componentTypesMap.set(typeSymbol, componentType);
        }
        hasComponent(componentType, entityId) {
          const typeSymbol = componentType.getId().getSymbol();
          const entitySymbol = entityId.getSymbol();
          const innerMap = this.componentTypeToComponentMap.get(typeSymbol);
          return innerMap?.has(entitySymbol) ?? false;
        }
        getComponent(componentType, entityId) {
          return this.withComponentEntry(componentType, entityId, (map, key) => map.get(key));
        }
        addComponent(component, entityId) {
          const typeId = component.componentTypeId;
          const componentType = this.getComponentType(typeId);
          const typeSymbol = typeId.getSymbol();
          const typeName = typeId.getName();
          const entitySymbol = entityId.getSymbol();
          let componentMap = this.componentTypeToComponentMap.get(typeSymbol);
          if (componentMap && componentMap.has(entitySymbol)) {
            throw new Error(`Could not add component with type '${typeName}' to repository: entity '${entityId.toString()}' is already associated with a component of this type.`);
          }
          if (!componentMap) {
            componentMap = /* @__PURE__ */ new Map();
            this.componentTypeToComponentMap.set(typeSymbol, componentMap);
          }
          componentMap.set(entitySymbol, component);
          this.addComponentType(componentType, entitySymbol);
          this.hooks.invokeHooks((h) => h.onAddComponent(componentType, component, entityId));
        }
        removeComponent(componentType, entityId) {
          const typeId = componentType.getId();
          const typeSymbol = typeId.getSymbol();
          const entitySymbol = entityId.getSymbol();
          const component = this.withComponentEntry(componentType, entityId, (map, key) => {
            const c = map.get(key);
            map.delete(key);
            if (map.size === 0) {
              this.componentTypeToComponentMap.delete(typeSymbol);
            }
            return c;
          });
          this.removeComponentType(typeSymbol, entitySymbol);
          this.hooks.invokeHooks((h) => h.onRemoveComponent(componentType, component, entityId));
        }
        hasEntity(entityId) {
          return this.entityToComponentTypesMap.has(entityId.getSymbol());
        }
        getEntityComponentTypes(entityId) {
          const entitySymbol = entityId.getSymbol();
          const componentTypesMap = this.entityToComponentTypesMap.get(entitySymbol);
          return componentTypesMap ? Array.from(componentTypesMap.values()) : _FluidComponentRepository.EMPTY_COMPONENT_TYPES;
        }
        removeEntityComponents(entityId) {
          const entitySymbol = entityId.getSymbol();
          const componentTypesMap = this.entityToComponentTypesMap.get(entitySymbol);
          if (!componentTypesMap)
            return;
          const componentTypes = Array.from(componentTypesMap.values());
          this.entityToComponentTypesMap.delete(entitySymbol);
          for (const componentType of componentTypes) {
            const typeSymbol = componentType.getId().getSymbol();
            const component = this.componentTypeToComponentMap.get(typeSymbol)?.get(entitySymbol);
            if (component) {
              this.componentTypeToComponentMap.get(typeSymbol).delete(entitySymbol);
              this.hooks.invokeHooks((h) => h.onRemoveComponent(componentType, component, entityId));
            }
          }
        }
        *getEntityComponents(entityId) {
          const entitySymbol = entityId.getSymbol();
          const componentTypesMap = this.entityToComponentTypesMap.get(entitySymbol);
          if (componentTypesMap) {
            for (const componentType of componentTypesMap.values()) {
              yield this.withComponentEntry(componentType, entityId, (map, key) => map.get(key));
            }
          }
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/component/type/FluidComponentType.js
  var FluidComponentType;
  var init_FluidComponentType = __esm({
    "../FluidEngine/dist/internal/core/component/type/FluidComponentType.js"() {
      FluidComponentType = class {
        id;
        factory;
        constructor(id, factory) {
          this.id = id;
          this.factory = factory;
        }
        getId() {
          return this.id;
        }
        is(component) {
          return this.id.equals(component.componentTypeId);
        }
        createComponent(data, copyData = false) {
          return this.factory.createComponent(this, data, copyData);
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/component/type/FluidComponentTypeId.js
  var FluidComponentTypeId;
  var init_FluidComponentTypeId = __esm({
    "../FluidEngine/dist/internal/core/component/type/FluidComponentTypeId.js"() {
      FluidComponentTypeId = class _FluidComponentTypeId {
        name;
        numericId;
        static prefix = "FluidComponentType";
        symbolId;
        stringified;
        constructor(name, numericId) {
          this.name = name;
          this.numericId = numericId;
          this.stringified = `${_FluidComponentTypeId.prefix}#${numericId}-${name}`;
          this.symbolId = Symbol(this.stringified);
        }
        getSymbol() {
          return this.symbolId;
        }
        getNumericId() {
          return this.numericId;
        }
        getName() {
          return this.name;
        }
        equals(other) {
          return other instanceof _FluidComponentTypeId && other.symbolId === this.symbolId;
        }
        toString() {
          return this.stringified;
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/component/type/FluidComponentTypeFactory.js
  var FluidComponentTypeFactory;
  var init_FluidComponentTypeFactory = __esm({
    "../FluidEngine/dist/internal/core/component/type/FluidComponentTypeFactory.js"() {
      init_FluidComponentType();
      init_FluidComponentTypeId();
      FluidComponentTypeFactory = class {
        componentFactory;
        nextNumericId = 0;
        removedNumericIds = /* @__PURE__ */ new Set();
        constructor(componentFactory) {
          this.componentFactory = componentFactory;
        }
        onRegisterComponentType(registry, componentType) {
        }
        onUnregisterComponentType(registry, componentType) {
          this.removedNumericIds.add(componentType.getId().getNumericId());
        }
        createComponentType(name) {
          let numericId;
          if (this.removedNumericIds.size > 0) {
            numericId = this.removedNumericIds.values().next().value;
            this.removedNumericIds.delete(numericId);
          } else {
            numericId = this.nextNumericId++;
          }
          return new FluidComponentType(new FluidComponentTypeId(name, numericId), this.componentFactory);
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/component/type/FluidComponentTypeRegistry.js
  var FluidComponentTypeRegistry;
  var init_FluidComponentTypeRegistry = __esm({
    "../FluidEngine/dist/internal/core/component/type/FluidComponentTypeRegistry.js"() {
      FluidComponentTypeRegistry = class {
        hooks;
        map = /* @__PURE__ */ new Map();
        constructor(hooks) {
          this.hooks = hooks;
        }
        hasComponentType(id) {
          return this.map.has(id.getSymbol());
        }
        getComponentType(componentTypeId) {
          const value = this.map.get(componentTypeId.getSymbol());
          if (!value) {
            throw new Error(`Could not retrieve component type '${componentTypeId.toString()}'. This type may not have been registered.`);
          }
          return value;
        }
        removeComponentType(componentTypeId) {
          const idSymbol = componentTypeId.getSymbol();
          const type = this.map.get(idSymbol);
          if (!type) {
            throw new Error(`Could not remove component type '${componentTypeId.toString()}'. This type may not have been registered.`);
          }
          this.map.delete(idSymbol);
          this.hooks.invokeHooks((hook) => hook.onUnregisterComponentType(this, type));
        }
        addComponentType(componentType) {
          const id = componentType.getId();
          const idSymbol = id.getSymbol();
          if (this.map.has(idSymbol)) {
            throw new Error(`Could not register component type '${id.toString()}'. This type has already been registered.`);
          }
          this.map.set(idSymbol, componentType);
          this.hooks.invokeHooks((hook) => hook.onRegisterComponentType(this, componentType));
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/component/type/FluidComponentTypeResolver.js
  var FluidComponentTypeResolver;
  var init_FluidComponentTypeResolver = __esm({
    "../FluidEngine/dist/internal/core/component/type/FluidComponentTypeResolver.js"() {
      FluidComponentTypeResolver = class {
        byNumericId = /* @__PURE__ */ new Map();
        bySymbol = /* @__PURE__ */ new Map();
        getOrThrowError(keyTypeName, key, map) {
          const componentType = map.get(key);
          if (!componentType) {
            throw new Error(`Failed to retrieve component type using key '${String(key)}' of type '${keyTypeName}'.`);
          }
          return componentType;
        }
        setOrThrowError(keyTypeName, key, componentType, map) {
          if (map.has(key)) {
            const existingTypeName = map.get(key).getId().getName();
            throw new Error(`Failed to store component type '${componentType.getId().getName()}' using key '${String(key)}' of type '${keyTypeName}': this key has already been set for component type '${existingTypeName}'`);
          }
          map.set(key, componentType);
        }
        onRegisterComponentType(registry, componentType) {
          const id = componentType.getId();
          this.setOrThrowError("number", id.getNumericId(), componentType, this.byNumericId);
          this.setOrThrowError("symbol", id.getSymbol(), componentType, this.bySymbol);
        }
        onUnregisterComponentType(registry, componentType) {
          const id = componentType.getId();
          this.byNumericId.delete(id.getNumericId());
          this.bySymbol.delete(id.getSymbol());
        }
        getBySymbol(symId) {
          return this.getOrThrowError("symbol", symId, this.bySymbol);
        }
        getByNumericId(numId) {
          return this.getOrThrowError("number", numId, this.byNumericId);
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/archetype/index.js
  var init_archetype = __esm({
    "../FluidEngine/dist/internal/core/archetype/index.js"() {
      init_FluidArchetype();
      init_FluidArchetypeRegistry();
    }
  });

  // ../FluidEngine/dist/internal/core/entity/FluidEntityArchetypeCoordinator.js
  var FluidEntityArchetypeCoordinator;
  var init_FluidEntityArchetypeCoordinator = __esm({
    "../FluidEngine/dist/internal/core/entity/FluidEntityArchetypeCoordinator.js"() {
      init_archetype();
      FluidEntityArchetypeCoordinator = class {
        archetypeRegistry;
        getEntityComponentTypes;
        entityArchetypeHooks;
        archetypeMap = /* @__PURE__ */ new Map();
        constructor(archetypeRegistry, getEntityComponentTypes, entityArchetypeHooks) {
          this.archetypeRegistry = archetypeRegistry;
          this.getEntityComponentTypes = getEntityComponentTypes;
          this.entityArchetypeHooks = entityArchetypeHooks;
        }
        computeArchetypeBitSet(entityId) {
          const componentTypeIterable = this.getEntityComponentTypes(entityId);
          return FluidArchetype.computeArchetypeBitSet(componentTypeIterable);
        }
        getArchetypeOfEntity(entityId) {
          const idSymbol = entityId.getSymbol();
          if (this.archetypeMap.has(idSymbol)) {
            return this.archetypeMap.get(idSymbol);
          }
          const bitSet = this.computeArchetypeBitSet(entityId);
          const archetype = this.archetypeRegistry.getOrCreate(bitSet);
          this.archetypeMap.set(idSymbol, archetype);
          return archetype;
        }
        onAddComponent(componentType, component, entityId) {
          const idSymbol = entityId.getSymbol();
          const currentBitSet = this.archetypeMap.get(idSymbol)?.getBitSet() ?? this.computeArchetypeBitSet(entityId);
          const currentArchetype = this.archetypeRegistry.getOrCreate(currentBitSet);
          const newBitSet = currentBitSet | FluidArchetype.getBitMask(componentType);
          const newArchetype = this.archetypeRegistry.getOrCreate(newBitSet);
          this.archetypeMap.set(idSymbol, newArchetype);
          this.entityArchetypeHooks.invokeHooks((h) => h.onEntityArchetypeExpansion(entityId, componentType, currentArchetype, newArchetype));
        }
        onRemoveComponent(componentType, component, entityId) {
          const idSymbol = entityId.getSymbol();
          const currentBitSet = this.archetypeMap.get(idSymbol)?.getBitSet() ?? this.computeArchetypeBitSet(entityId);
          const currentArchetype = this.archetypeRegistry.getOrCreate(currentBitSet);
          const newBitSet = currentBitSet & ~FluidArchetype.getBitMask(componentType);
          const newArchetype = this.archetypeRegistry.getOrCreate(newBitSet);
          this.archetypeMap.set(idSymbol, newArchetype);
          this.entityArchetypeHooks.invokeHooks((h) => h.onEntityArchetypeReduction(entityId, componentType, currentArchetype, newArchetype));
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/entity/FluidEntityId.js
  var FluidEntityId;
  var init_FluidEntityId = __esm({
    "../FluidEngine/dist/internal/core/entity/FluidEntityId.js"() {
      FluidEntityId = class _FluidEntityId {
        stringId;
        symbol;
        constructor(stringId) {
          this.stringId = stringId;
          this.symbol = Symbol(this.stringId);
        }
        getSymbol() {
          return this.symbol;
        }
        equals(other) {
          return other instanceof _FluidEntityId ? other.symbol === this.symbol : other.toString() === this.toString();
        }
        toString() {
          return this.stringId;
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/entity/FluidEntityFactory.js
  var FluidEntityFactory;
  var init_FluidEntityFactory = __esm({
    "../FluidEngine/dist/internal/core/entity/FluidEntityFactory.js"() {
      init_FluidEntityId();
      FluidEntityFactory = class _FluidEntityFactory {
        static prefix = "FluidEntity";
        tag;
        constructor() {
          this.tag = `${_FluidEntityFactory.prefix}_`;
        }
        createEntityId() {
          const tag = this.tag;
          const stringId = tag + Date.now();
          return new FluidEntityId(stringId);
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/entity/FluidEntityManager.js
  var FluidEntityManager;
  var init_FluidEntityManager = __esm({
    "../FluidEngine/dist/internal/core/entity/FluidEntityManager.js"() {
      FluidEntityManager = class {
        entityFactory;
        proxyFactory;
        idMap = /* @__PURE__ */ new Map();
        proxyMap = /* @__PURE__ */ new Map();
        constructor(entityFactory, proxyFactory) {
          this.entityFactory = entityFactory;
          this.proxyFactory = proxyFactory;
        }
        getEntityBySymbol(entitySymbol) {
          return this.idMap.get(entitySymbol);
        }
        getEntityResolver() {
          return this;
        }
        getEntityFactory() {
          return this.entityFactory;
        }
        getEntityProxyFactory() {
          return this.proxyFactory;
        }
        getEntities() {
          return this.idMap.values();
        }
        hasEntity(entityId) {
          return this.idMap.has(entityId.getSymbol());
        }
        removeEntity(entityId) {
          this.idMap.delete(entityId.getSymbol());
          this.proxyMap.delete(entityId.getSymbol());
        }
        addEntity(entityId) {
          this.idMap.set(entityId.getSymbol(), entityId);
        }
        createEntity() {
          const id = this.entityFactory.createEntityId();
          this.addEntity(id);
          return id;
        }
        getEntityProxy(entityId) {
          const key = entityId.getSymbol();
          let proxy = this.proxyMap.get(key);
          if (!proxy) {
            proxy = this.proxyFactory.createProxy(entityId);
            this.proxyMap.set(key, proxy);
          }
          return proxy;
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/entity/FluidEntityProxy.js
  var FluidEntityProxy;
  var init_FluidEntityProxy = __esm({
    "../FluidEngine/dist/internal/core/entity/FluidEntityProxy.js"() {
      FluidEntityProxy = class {
        entityId;
        componentRepository;
        constructor(entityId, componentRepository) {
          this.entityId = entityId;
          this.componentRepository = componentRepository;
        }
        hasComponent(componentType) {
          return this.componentRepository.hasComponent(componentType, this.entityId);
        }
        getComponent(componentType) {
          return this.componentRepository.getComponent(componentType, this.entityId);
        }
        addComponent(component) {
          this.componentRepository.addComponent(component, this.entityId);
        }
        removeComponent(componentType) {
          this.componentRepository.removeComponent(componentType, this.entityId);
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/entity/FluidEntityProxyFactory.js
  var FluidEntityProxyFactory;
  var init_FluidEntityProxyFactory = __esm({
    "../FluidEngine/dist/internal/core/entity/FluidEntityProxyFactory.js"() {
      init_FluidEntityProxy();
      FluidEntityProxyFactory = class {
        componentRepository;
        constructor(componentRepository) {
          this.componentRepository = componentRepository;
        }
        createProxy(entityId) {
          return new FluidEntityProxy(entityId, this.componentRepository);
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/node/FluidNodeFactory.js
  var FluidNodeFactory;
  var init_FluidNodeFactory = __esm({
    "../FluidEngine/dist/internal/core/node/FluidNodeFactory.js"() {
      FluidNodeFactory = class {
        getComponent;
        constructor(getComponent) {
          this.getComponent = getComponent;
        }
        createNode(schemaMeta, entityId) {
          const schemaId = schemaMeta.id, schema24 = schemaMeta.schema;
          const node = { entityId };
          for (const [key, componentType] of Object.entries(schema24)) {
            const component = this.getComponent(componentType, entityId);
            if (!component) {
              throw new Error(`Failed to create node from schema '${schemaId.getName()}': could not find component of type '${componentType.getId().getName()}' associated with entity id '${entityId.toString()}'`);
            }
            node[key] = component.data;
          }
          return node;
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/node/FluidNodeManager.js
  var FluidNodeManager;
  var init_FluidNodeManager = __esm({
    "../FluidEngine/dist/internal/core/node/FluidNodeManager.js"() {
      FluidNodeManager = class {
        nodeRepository;
        nodeIndex;
        nodeFactory;
        nodeSchemaRegistry;
        getArchetypeOfNodeSchema;
        nodeSchemaIndex;
        constructor(nodeRepository, nodeIndex, nodeFactory, nodeSchemaRegistry, getArchetypeOfNodeSchema, nodeSchemaIndex) {
          this.nodeRepository = nodeRepository;
          this.nodeIndex = nodeIndex;
          this.nodeFactory = nodeFactory;
          this.nodeSchemaRegistry = nodeSchemaRegistry;
          this.getArchetypeOfNodeSchema = getArchetypeOfNodeSchema;
          this.nodeSchemaIndex = nodeSchemaIndex;
        }
        getNodeIndex() {
          return this.nodeIndex;
        }
        getNodeRepository() {
          return this.nodeRepository;
        }
        getNodeFactory() {
          return this.nodeFactory;
        }
        getNodeSchemaRegistry() {
          return this.nodeSchemaRegistry;
        }
        /*
            Archetype Hook Implementation
        */
        onEntityArchetypeExpansion(entityId, addedComponentType, previousArchetype, newArchetype) {
          for (const schemaMeta of this.nodeSchemaIndex.getSchemasWithComponentType(addedComponentType)) {
            const schemaId = schemaMeta.id;
            const schemaArchetype = this.getArchetypeOfNodeSchema(schemaMeta);
            if (!newArchetype.isSuperSetOf(schemaArchetype))
              continue;
            if (this.nodeRepository.hasNode(schemaId, entityId))
              continue;
            try {
              const node = this.nodeFactory.createNode(schemaMeta, entityId);
              this.nodeRepository.addNode(schemaId, node);
            } catch (e) {
              throw new Error(`Failed to create/add node for entity ${entityId.toString()} under schema '${schemaId.getName()}': ${e.message}`, { cause: e });
            }
          }
        }
        onEntityArchetypeReduction(entityId, removedComponentType, previousArchetype, newArchetype) {
          for (const schemaMeta of this.nodeSchemaIndex.getSchemasWithComponentType(removedComponentType)) {
            const schemaId = schemaMeta.id;
            const schemaArchetype = this.getArchetypeOfNodeSchema(schemaMeta);
            if (!newArchetype.isSuperSetOf(schemaArchetype) && this.nodeRepository.hasNode(schemaId, entityId)) {
              this.nodeRepository.removeNode(schemaId, entityId);
            }
          }
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/node/FluidNodeRepository.js
  var FluidNodeRepository;
  var init_FluidNodeRepository = __esm({
    "../FluidEngine/dist/internal/core/node/FluidNodeRepository.js"() {
      FluidNodeRepository = class _FluidNodeRepository {
        static EMPTY_ITERABLE = Object.freeze([]);
        nodeMap = /* @__PURE__ */ new Map();
        constructor() {
        }
        getInnerMap(schemaId) {
          const idSymbol = schemaId.getSymbol();
          const innerMap = this.nodeMap.get(idSymbol);
          if (!innerMap)
            throw new Error(`Failed to retrieve node with schema '${schemaId.getName()}': schema id was not set in node repository.`);
          return innerMap;
        }
        hasNode(schemaId, entityId) {
          const idSymbol = schemaId.getSymbol();
          const innerMap = this.nodeMap.get(idSymbol);
          return innerMap && innerMap.has(entityId);
        }
        getNode(schemaId, entityId) {
          const innerMap = this.getInnerMap(schemaId);
          const node = innerMap.get(entityId);
          if (!node) {
            throw new Error(`Failed to get a node with schema '${schemaId.getName()}' for entity id '${entityId.toString()}': node not found.`);
          }
          return node;
        }
        removeNode(schemaId, entityId) {
          const innerMap = this.getInnerMap(schemaId);
          const node = innerMap.get(entityId);
          if (!node) {
            throw new Error(`Failed to remove a node with schema '${schemaId.getName()}' for entity id '${entityId.toString()}': node not found.`);
          }
          innerMap.delete(entityId);
        }
        hasNodes(schemaId) {
          const idSymbol = schemaId.getSymbol();
          return this.nodeMap.has(idSymbol);
        }
        getNodes(schemaId) {
          const idSymbol = schemaId.getSymbol();
          const innerMap = this.nodeMap.get(idSymbol);
          return innerMap?.values() ?? _FluidNodeRepository.EMPTY_ITERABLE;
        }
        removeNodes(schemaId) {
          const idSymbol = schemaId.getSymbol();
          this.nodeMap.delete(idSymbol);
        }
        addNode(schemaId, node) {
          const idSymbol = schemaId.getSymbol();
          let innerMap = this.nodeMap.get(idSymbol);
          if (innerMap && innerMap.has(node.entityId)) {
            throw new Error(`Failed to add node '${node}' with schema '${schemaId.getName()}': a node for this entity already exists under this schema.`);
          }
          if (!innerMap) {
            innerMap = /* @__PURE__ */ new Map();
            this.nodeMap.set(idSymbol, innerMap);
          }
          innerMap.set(node.entityId, node);
        }
        getNodesWithSchema(meta3) {
          return this.getNodes(meta3.id);
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/component/index.js
  var init_component2 = __esm({
    "../FluidEngine/dist/internal/core/component/index.js"() {
      init_FluidComponent();
      init_FluidComponentFactory();
      init_FluidComponentManager();
      init_FluidComponentRepository();
      init_FluidComponentType();
      init_FluidComponentTypeFactory();
      init_FluidComponentTypeId();
      init_FluidComponentTypeRegistry();
      init_FluidComponentTypeResolver();
    }
  });

  // ../FluidEngine/dist/internal/core/entity/index.js
  var init_entity2 = __esm({
    "../FluidEngine/dist/internal/core/entity/index.js"() {
      init_FluidEntityArchetypeCoordinator();
      init_FluidEntityFactory();
      init_FluidEntityId();
      init_FluidEntityManager();
      init_FluidEntityProxy();
      init_FluidEntityProxyFactory();
    }
  });

  // ../FluidEngine/dist/internal/core/node/schema/FluidNodeSchemaId.js
  var FluidNodeSchemaId;
  var init_FluidNodeSchemaId = __esm({
    "../FluidEngine/dist/internal/core/node/schema/FluidNodeSchemaId.js"() {
      FluidNodeSchemaId = class _FluidNodeSchemaId {
        idSymbol;
        timeStamp;
        stringified;
        constructor(name) {
          this.timeStamp = Date.now();
          this.stringified = `FluidNodeSchemaId[${this.timeStamp}ms](${name})`;
          this.idSymbol = Symbol(this.stringified);
        }
        equals(other) {
          return other instanceof _FluidNodeSchemaId && other.idSymbol === this.idSymbol;
        }
        getName() {
          return this.stringified;
        }
        getSymbol() {
          return this.idSymbol;
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/node/schema/FluidNodeSchemaIndex.js
  var FluidNodeSchemaIndex;
  var init_FluidNodeSchemaIndex = __esm({
    "../FluidEngine/dist/internal/core/node/schema/FluidNodeSchemaIndex.js"() {
      init_dist();
      init_archetype();
      FluidNodeSchemaIndex = class _FluidNodeSchemaIndex {
        getSchemaBySymbol;
        getArchetypeOfSchema;
        archetypeToSchemaMap = /* @__PURE__ */ new Map();
        componentTypeToSchemasMap = /* @__PURE__ */ new Map();
        static EMPTY_SET = Object.freeze(/* @__PURE__ */ new Set());
        constructor(getSchemaBySymbol, getArchetypeOfSchema) {
          this.getSchemaBySymbol = getSchemaBySymbol;
          this.getArchetypeOfSchema = getArchetypeOfSchema;
        }
        onRegisterNodeSchema(meta3) {
          const schemaSymbol = meta3.id.getSymbol();
          const archetype = this.getArchetypeOfSchema(meta3);
          const bitSet = archetype.getBitSet();
          let schemaSet = this.archetypeToSchemaMap.get(bitSet);
          if (!schemaSet) {
            schemaSet = /* @__PURE__ */ new Set();
            this.archetypeToSchemaMap.set(bitSet, schemaSet);
          }
          schemaSet.add(schemaSymbol);
          for (const componentType of Object.values(meta3.schema)) {
            const typeSymbol = componentType.getId().getSymbol();
            let schemaSet2 = this.componentTypeToSchemasMap.get(typeSymbol);
            if (!schemaSet2) {
              schemaSet2 = /* @__PURE__ */ new Set();
              this.componentTypeToSchemasMap.set(typeSymbol, schemaSet2);
            }
            schemaSet2.add(schemaSymbol);
          }
        }
        onUnregisterNodeSchema(meta3) {
          const schemaSymbol = meta3.id.getSymbol();
          const archetype = this.getArchetypeOfSchema(meta3);
          const bitSet = archetype.getBitSet();
          const schemaSet = this.archetypeToSchemaMap.get(bitSet);
          if (schemaSet) {
            schemaSet.delete(schemaSymbol);
            if (schemaSet.size == 0)
              this.archetypeToSchemaMap.delete(bitSet);
          }
          for (const componentType of Object.values(meta3.schema)) {
            const typeSymbol = componentType.getId().getSymbol();
            let schemaSet2 = this.componentTypeToSchemasMap.get(typeSymbol);
            if (schemaSet2) {
              schemaSet2.delete(schemaSymbol);
              if (schemaSet2.size == 0)
                this.componentTypeToSchemasMap.delete(typeSymbol);
            }
          }
        }
        getLazyResolvedMetaIterable(schemaSymbolSet) {
          return getLazyMappedIterable(schemaSymbolSet ?? _FluidNodeSchemaIndex.EMPTY_SET, (symbol) => {
            const schema24 = this.getSchemaBySymbol(symbol);
            if (!schema24)
              throw new Error(`Schema not found for symbol: ${String(symbol)}`);
            return schema24;
          });
        }
        getSchemasWithComponentType(componentType) {
          const typeSymbol = componentType.getId().getSymbol();
          const schemaSymbolSet = this.componentTypeToSchemasMap.get(typeSymbol);
          return this.getLazyResolvedMetaIterable(schemaSymbolSet);
        }
        getSchemasWithArchetype(archetype) {
          if (!(archetype instanceof FluidArchetype))
            throw new Error("Unsupported archetype implementation passed to 'FluidNodeSchemaIndex.getSchemasWithArchetype'. Expected 'FluidArchetype'");
          const bitSet = archetype.getBitSet();
          const schemaSymbolSet = this.archetypeToSchemaMap.get(bitSet);
          return this.getLazyResolvedMetaIterable(schemaSymbolSet);
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/node/schema/FluidNodeSchemaRegistry.js
  var FluidNodeSchemaRegistry;
  var init_FluidNodeSchemaRegistry = __esm({
    "../FluidEngine/dist/internal/core/node/schema/FluidNodeSchemaRegistry.js"() {
      init_FluidNodeSchemaId();
      FluidNodeSchemaRegistry = class {
        hooks;
        schemaMap = /* @__PURE__ */ new Map();
        constructor(hooks) {
          this.hooks = hooks;
        }
        hasSchema(schemaId) {
          return this.schemaMap.has(schemaId.getSymbol());
        }
        getSchemaBySymbol(idSymbol) {
          const meta3 = this.schemaMap.get(idSymbol);
          if (!meta3)
            throw new Error(`Could not find schema using symbol.`);
          return meta3;
        }
        getSchema(schemaId) {
          const idSymbol = schemaId.getSymbol();
          const meta3 = this.schemaMap.get(idSymbol);
          if (!meta3)
            throw new Error(`Could not find schema '${schemaId.getName()}'`);
          return meta3;
        }
        addSchema(schema24, name) {
          const id = new FluidNodeSchemaId(name);
          const meta3 = { id, schema: schema24 };
          this.schemaMap.set(id.getSymbol(), meta3);
          this.hooks.invokeHooks((h) => h.onRegisterNodeSchema(meta3));
          return meta3;
        }
        removeSchema(schemaId) {
          const idSymbol = schemaId.getSymbol();
          const meta3 = this.schemaMap.get(idSymbol);
          if (!meta3)
            throw new Error(`Could not remove schema '${schemaId.getName()}'`);
          this.schemaMap.delete(idSymbol);
          this.hooks.invokeHooks((h) => h.onUnregisterNodeSchema(meta3));
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/node/index.js
  var init_node2 = __esm({
    "../FluidEngine/dist/internal/core/node/index.js"() {
      init_FluidNodeFactory();
      init_FluidNodeManager();
      init_FluidNodeRepository();
      init_FluidNodeSchemaArchetypeBridge();
      init_FluidNodeSchemaId();
      init_FluidNodeSchemaIndex();
      init_FluidNodeSchemaRegistry();
    }
  });

  // ../FluidEngine/dist/internal/core/system/FluidSystemMeta.js
  var FluidSystemMeta;
  var init_FluidSystemMeta = __esm({
    "../FluidEngine/dist/internal/core/system/FluidSystemMeta.js"() {
      FluidSystemMeta = class {
        systemName;
        nodeSchemaMeta;
        constructor(systemName, nodeSchemaMeta) {
          this.systemName = systemName;
          this.nodeSchemaMeta = nodeSchemaMeta;
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/system/FluidSystem.js
  var FluidSystem;
  var init_FluidSystem = __esm({
    "../FluidEngine/dist/internal/core/system/FluidSystem.js"() {
      init_FluidSystemMeta();
      FluidSystem = class {
        systemMeta;
        constructor(name, nodeSchemaMeta) {
          this.systemMeta = new FluidSystemMeta(name, nodeSchemaMeta);
        }
        getSystemMeta() {
          return this.systemMeta;
        }
        updateNodes(nodes) {
          for (const node of nodes) {
            if (this.updateNode)
              this.updateNode(node);
          }
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/system/FluidSystemOrchestrator.js
  var FluidSystemOrchestrator;
  var init_FluidSystemOrchestrator = __esm({
    "../FluidEngine/dist/internal/core/system/FluidSystemOrchestrator.js"() {
      init_dist();
      FluidSystemOrchestrator = class {
        phaseList = new OrderedArrayList();
        //Store phases in proper order
        hasPhase(phase) {
          return this.phaseList.has(phase);
        }
        addPhase(phase, phaseOrder) {
          if (this.phaseList.has(phase)) {
            throw new Error(`Failed to add phase '${phase.getName()}': phase has already been added.`);
          }
          this.phaseList.insert(phase, phaseOrder);
        }
        pushPhase(phase) {
          this.addPhase(phase, this.phaseList.getSize());
        }
        pushPhases(...phases) {
          phases.forEach((phase) => this.pushPhase(phase));
        }
        removePhase(phase) {
          if (!this.phaseList.has(phase)) {
            throw new Error(`Failed to remove phase '${phase.getName()}': phase has not been added.`);
          }
          this.phaseList.remove(phase);
        }
        getPhases() {
          return this.phaseList.getAll();
        }
        update(nodeIndex) {
          for (const phase of this.phaseList.getAll()) {
            try {
              phase.update(nodeIndex);
            } catch (error) {
              console.error(`Failed to complete phase update '${phase.getName()}':
${error}`);
            }
          }
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/system/FluidSystemPhase.js
  var FluidSystemPhase;
  var init_FluidSystemPhase = __esm({
    "../FluidEngine/dist/internal/core/system/FluidSystemPhase.js"() {
      init_OrderedArrayList();
      FluidSystemPhase = class {
        name;
        preUpdate;
        postUpdate;
        systemList = new OrderedArrayList();
        constructor(name, preUpdate, postUpdate) {
          this.name = name;
          this.preUpdate = preUpdate;
          this.postUpdate = postUpdate;
        }
        getName() {
          return this.name;
        }
        hasSystem(system) {
          return this.systemList.has(system);
        }
        addSystem(system, inPhaseOrder) {
          if (this.systemList.has(system)) {
            throw new Error(`Failed to add system '${system.getSystemMeta().systemName}' to phase '${this.name}': system has already been added.`);
          }
          this.systemList.insert(system, inPhaseOrder);
        }
        pushSystem(system) {
          this.addSystem(system, this.systemList.getSize());
        }
        pushSystems(...systems) {
          systems.forEach((system) => this.pushSystem(system));
        }
        removeSystem(system) {
          if (!this.systemList.has(system)) {
            throw new Error(`Failed to remove system '${system.getSystemMeta().systemName}' from phase '${this.name}': system was not found.`);
          }
          this.systemList.remove(system);
        }
        getSystems() {
          return this.systemList.getAll();
        }
        update(nodeIndex) {
          try {
            this.preUpdate?.();
          } catch (error) {
            console.error(`Failed to complete phase '${this.getName()}' pre-update:
${error}`);
          }
          for (const system of this.systemList.getAll()) {
            try {
              system.updateNodes(nodeIndex.getNodesWithSchema(system.getSystemMeta().nodeSchemaMeta));
            } catch (error) {
              console.error(`Failed to complete system '${system.getSystemMeta().systemName}' update:
${error}`);
            }
          }
          try {
            this.postUpdate?.();
          } catch (error) {
            console.error(`Failed to complete phase '${this.getName()}' post-update:
${error}`);
          }
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/system/index.js
  var init_system2 = __esm({
    "../FluidEngine/dist/internal/core/system/index.js"() {
      init_FluidSystem();
      init_FluidSystemMeta();
      init_FluidSystemOrchestrator();
      init_FluidSystemPhase();
    }
  });

  // ../FluidEngine/dist/internal/core/util/FluidHookDispatcher.js
  var FluidHookDispatcher;
  var init_FluidHookDispatcher = __esm({
    "../FluidEngine/dist/internal/core/util/FluidHookDispatcher.js"() {
      FluidHookDispatcher = class {
        hooks = [];
        constructor(hooks = []) {
          hooks.forEach((h) => this.addHook(h));
        }
        addHook(hook) {
          if (this.hooks.includes(hook)) {
            throw new Error(`Cannot add hook: hook is already registered.`);
          }
          this.hooks.push(hook);
        }
        removeHook(hook) {
          const index = this.hooks.indexOf(hook);
          if (index === -1) {
            throw new Error(`Cannot remove hook: hook is not registered.`);
          }
          this.hooks.splice(index, 1);
        }
        invokeHooks(fn) {
          for (const hook of this.hooks) {
            try {
              fn(hook);
            } catch (error) {
              console.error("Hook invocation threw an error:", error);
            }
          }
        }
        hookList() {
          return [...this.hooks];
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/util/index.js
  var init_util2 = __esm({
    "../FluidEngine/dist/internal/core/util/index.js"() {
      init_FluidHookDispatcher();
    }
  });

  // ../FluidEngine/dist/internal/index.js
  var init_internal = __esm({
    "../FluidEngine/dist/internal/index.js"() {
      init_Fluid();
      init_FluidEngine();
      init_FluidCore();
      init_archetype();
      init_component2();
      init_entity2();
      init_node2();
      init_system2();
      init_util2();
    }
  });

  // ../FluidEngine/dist/internal/core/node/schema/FluidNodeSchemaArchetypeBridge.js
  var FluidNodeSchemaArchetypeBridge;
  var init_FluidNodeSchemaArchetypeBridge = __esm({
    "../FluidEngine/dist/internal/core/node/schema/FluidNodeSchemaArchetypeBridge.js"() {
      init_internal();
      FluidNodeSchemaArchetypeBridge = class {
        archetypeRegistry;
        schemaArchetypeHooks;
        schemaToArchetypeMap = /* @__PURE__ */ new Map();
        // Maps each schema symbol to its archetype
        constructor(archetypeRegistry, schemaArchetypeHooks) {
          this.archetypeRegistry = archetypeRegistry;
          this.schemaArchetypeHooks = schemaArchetypeHooks;
        }
        computeArchetypeBitSet(schema24) {
          return FluidArchetype.computeArchetypeBitSet(Object.values(schema24));
        }
        /**
         * Retrieves archetype of schema if cached; otherwise, computes and interns the archetype in the archetype registry and then caches it locally.
         */
        getOrCreateArchetype(meta3) {
          const idSymbol = meta3.id.getSymbol();
          let archetype = this.schemaToArchetypeMap.get(idSymbol);
          if (archetype) {
            return archetype;
          }
          const bitSet = this.computeArchetypeBitSet(meta3.schema);
          archetype = this.archetypeRegistry.getOrCreate(bitSet);
          this.schemaToArchetypeMap.set(idSymbol, archetype);
          this.schemaArchetypeHooks.invokeHooks((h) => h.onRegisterSchemaArchetype(meta3, archetype));
          return archetype;
        }
        removeArchetype(meta3) {
          const idSymbol = meta3.id.getSymbol();
          const archetype = this.schemaToArchetypeMap.get(idSymbol);
          if (archetype) {
            this.schemaToArchetypeMap.delete(idSymbol);
            this.schemaArchetypeHooks.invokeHooks((h) => h.onRemoveSchemaArchetype(meta3, archetype));
          }
        }
        onRegisterNodeSchema(meta3) {
          this.getOrCreateArchetype(meta3);
        }
        onUnregisterNodeSchema(meta3) {
          this.removeArchetype(meta3);
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/core/FluidCore.js
  var FLUID_CORE_SYMBOL, FluidCore;
  var init_FluidCore = __esm({
    "../FluidEngine/dist/internal/core/FluidCore.js"() {
      init_FluidArchetypeRegistry();
      init_FluidComponentFactory();
      init_FluidComponentManager();
      init_FluidComponentRepository();
      init_FluidComponentTypeFactory();
      init_FluidComponentTypeRegistry();
      init_FluidComponentTypeResolver();
      init_FluidEntityArchetypeCoordinator();
      init_FluidEntityFactory();
      init_FluidEntityManager();
      init_FluidEntityProxyFactory();
      init_FluidNodeFactory();
      init_FluidNodeManager();
      init_FluidNodeRepository();
      init_FluidNodeSchemaArchetypeBridge();
      init_FluidNodeSchemaIndex();
      init_FluidNodeSchemaRegistry();
      init_FluidSystemOrchestrator();
      init_FluidHookDispatcher();
      FLUID_CORE_SYMBOL = Symbol.for("FluidCore");
      FluidCore = class _FluidCore {
        entityManager;
        componentManager;
        systemOrchestrator;
        nodeManager;
        static bootstrap() {
          const componentTypeRegistryHookDispatcher = new FluidHookDispatcher();
          const componentTypeRegistry = new FluidComponentTypeRegistry(componentTypeRegistryHookDispatcher);
          const componentRepositoryHookDispatcher = new FluidHookDispatcher();
          const componentRepository = new FluidComponentRepository(componentTypeRegistry.getComponentType.bind(componentTypeRegistry), componentRepositoryHookDispatcher);
          const componentFactory = new FluidComponentFactory();
          const componentTypeResolver = new FluidComponentTypeResolver();
          const componentTypeFactory = new FluidComponentTypeFactory(componentFactory);
          const componentManager = new FluidComponentManager(componentTypeFactory, componentTypeRegistry, componentTypeResolver, componentFactory, componentRepository);
          const archetypeRegistry = new FluidArchetypeRegistry();
          const entityArchetypeHookDispatcher = new FluidHookDispatcher();
          const entityArchetypeCoordinator = new FluidEntityArchetypeCoordinator(archetypeRegistry, (entityId) => componentRepository.getEntityComponentTypes(entityId), entityArchetypeHookDispatcher);
          const nodeSchemaArchetypeHookDispatcher = new FluidHookDispatcher();
          const nodeSchemaArchetypeBridge = new FluidNodeSchemaArchetypeBridge(archetypeRegistry, nodeSchemaArchetypeHookDispatcher);
          const nodeRepository = new FluidNodeRepository();
          const nodeFactory = new FluidNodeFactory(componentRepository.getComponent.bind(componentRepository));
          const nodeSchemaRegistryHookDispatcher = new FluidHookDispatcher();
          const nodeSchemaRegistry = new FluidNodeSchemaRegistry(nodeSchemaRegistryHookDispatcher);
          const getNodeSchemaBySymbol = nodeSchemaRegistry.getSchemaBySymbol.bind(nodeSchemaRegistry);
          const getFluidArchetypeOfNodeSchema = nodeSchemaArchetypeBridge.getOrCreateArchetype.bind(nodeSchemaArchetypeBridge);
          const nodeSchemaIndex = new FluidNodeSchemaIndex(getNodeSchemaBySymbol, getFluidArchetypeOfNodeSchema);
          const nodeManager = new FluidNodeManager(nodeRepository, nodeRepository, nodeFactory, nodeSchemaRegistry, getFluidArchetypeOfNodeSchema, nodeSchemaIndex);
          const entityProxyFactory = new FluidEntityProxyFactory(componentRepository);
          const entityManager = new FluidEntityManager(new FluidEntityFactory(), entityProxyFactory);
          const systemOrchestrator = new FluidSystemOrchestrator();
          componentTypeRegistryHookDispatcher.addHook(componentTypeFactory);
          componentRepositoryHookDispatcher.addHook(entityArchetypeCoordinator);
          nodeSchemaRegistryHookDispatcher.addHook(nodeSchemaIndex);
          entityArchetypeHookDispatcher.addHook(nodeManager);
          const core = new _FluidCore(entityManager, componentManager, systemOrchestrator, nodeManager);
          return core;
        }
        static isFluidCore(core) {
          return core[FLUID_CORE_SYMBOL] === true;
        }
        static {
          Object.defineProperty(_FluidCore.prototype, FLUID_CORE_SYMBOL, {
            value: true,
            writable: false,
            enumerable: false,
            configurable: false
          });
        }
        constructor(entityManager, componentManager, systemOrchestrator, nodeManager) {
          this.entityManager = entityManager;
          this.componentManager = componentManager;
          this.systemOrchestrator = systemOrchestrator;
          this.nodeManager = nodeManager;
        }
        update() {
          this.systemOrchestrator.update(this.getNodeManager().getNodeIndex());
        }
        getEntityManager() {
          return this.entityManager;
        }
        getComponentManager() {
          return this.componentManager;
        }
        getSystemOrchestrator() {
          return this.systemOrchestrator;
        }
        getNodeManager() {
          return this.nodeManager;
        }
      };
    }
  });

  // ../FluidEngine/dist/internal/Fluid.js
  var FluidInternal, fluidInternal;
  var init_Fluid = __esm({
    "../FluidEngine/dist/internal/Fluid.js"() {
      init_dist();
      init_FluidCore();
      (function(FluidInternal2) {
        function initialize(core2) {
          CoreRuntime.initialize(core2);
          return core2;
        }
        FluidInternal2.initialize = initialize;
        function bootstrap() {
          return FluidInternal2.initialize(FluidCore.bootstrap());
        }
        FluidInternal2.bootstrap = bootstrap;
        function core() {
          return CoreRuntime.getInstance();
        }
        FluidInternal2.core = core;
        function defineComponentType(name) {
          const componentManager = FluidInternal2.core().getComponentManager();
          const componentType = componentManager.getComponentTypeFactory().createComponentType(name);
          componentManager.getComponentTypeRegistry().addComponentType(componentType);
          return componentType;
        }
        FluidInternal2.defineComponentType = defineComponentType;
        function registerNodeSchema(nodeSchema2, name) {
          return FluidInternal2.core().getNodeManager().getNodeSchemaRegistry().addSchema(nodeSchema2, name);
        }
        FluidInternal2.registerNodeSchema = registerNodeSchema;
        function getEntityProxy(entityId) {
          return FluidInternal2.core().getEntityManager().getEntityProxy(entityId);
        }
        FluidInternal2.getEntityProxy = getEntityProxy;
        function removeEntity(entityId) {
          FluidInternal2.core().getEntityManager().removeEntity(entityId);
          FluidInternal2.core().getComponentManager().getComponentRepository().removeEntityComponents(entityId);
        }
        FluidInternal2.removeEntity = removeEntity;
        function addEntityComponent(entityId, component) {
          FluidInternal2.core().getComponentManager().getComponentRepository().addComponent(component, entityId);
        }
        FluidInternal2.addEntityComponent = addEntityComponent;
        function addEntityComponents(entityId, ...components) {
          const componentRepo = FluidInternal2.core().getComponentManager().getComponentRepository();
          for (const component of components) {
            componentRepo.addComponent(component, entityId);
          }
        }
        FluidInternal2.addEntityComponents = addEntityComponents;
        function createEntityWithComponents(...components) {
          const entityId = FluidInternal2.core().getEntityManager().createEntity();
          FluidInternal2.addEntityComponents(entityId, ...components);
          return entityId;
        }
        FluidInternal2.createEntityWithComponents = createEntityWithComponents;
        function getEntityComponent(entityId, componentType) {
          return FluidInternal2.core().getComponentManager().getComponentRepository().getComponent(componentType, entityId);
        }
        FluidInternal2.getEntityComponent = getEntityComponent;
        function removeEntityComponent(entityId, componentType) {
          FluidInternal2.core().getComponentManager().getComponentRepository().removeComponent(componentType, entityId);
        }
        FluidInternal2.removeEntityComponent = removeEntityComponent;
        function entityHasComponent(entityId, componentType) {
          return FluidInternal2.core().getComponentManager().getComponentRepository().hasComponent(componentType, entityId);
        }
        FluidInternal2.entityHasComponent = entityHasComponent;
      })(FluidInternal || (FluidInternal = {}));
      fluidInternal = FluidInternal;
    }
  });

  // ../FluidEngine/dist/index.js
  var init_dist = __esm({
    "../FluidEngine/dist/index.js"() {
      init_api();
      init_lib();
      init_FluidEngine();
      init_Fluid();
      init_internal();
    }
  });

  // src/client/Client.ts
  var ClientContext;
  var init_Client = __esm({
    "src/client/Client.ts"() {
      ClientContext = class {
        constructor(engineInstance, worldContext, renderer) {
          this.engineInstance = engineInstance;
          this.worldContext = worldContext;
          this.renderer = renderer;
        }
        displayBoundingBoxes = false;
        displayEntityAxes = false;
        displayDebugInfo = false;
        displayChunks = false;
        setZoomLevel(level) {
          this.engineInstance.PIXELS_PER_METER = 10 * level;
        }
        getZoomLevel() {
          return this.engineInstance.PIXELS_PER_METER / 10;
        }
        getSimulationSpeed() {
          return this.engineInstance.deltaTime * 60;
        }
        setSimulationSpeed(speed) {
          this.engineInstance.deltaTime = speed / 60;
        }
      };
    }
  });

  // src/client/renderer/Renderer.ts
  var defaultResizeHandler, CanvasRenderer;
  var init_Renderer = __esm({
    "src/client/renderer/Renderer.ts"() {
      defaultResizeHandler = function(prevWidth, prevHeight, newWidth, newHeight) {
      };
      CanvasRenderer = class {
        canvasElement;
        renderContext;
        scale;
        renderBaseColor;
        width;
        height;
        resizeHandler;
        constructor(canvasElement, { scale = 0.98, renderBaseColor = "black", onresize = defaultResizeHandler } = {}) {
          this.canvasElement = canvasElement;
          this.renderContext = canvasElement.getContext("2d");
          this.scale = scale;
          this.renderBaseColor = renderBaseColor;
          this.width = canvasElement.width;
          this.height = canvasElement.height;
          this.resizeHandler = onresize.bind(this);
          window.addEventListener("resize", this.updateSize.bind(this));
          this.updateSize();
        }
        getWidth() {
          return this.width;
        }
        getHeight() {
          return this.height;
        }
        updateSize() {
          const prevWidth = this.width, prevHeight = this.height, newWidth = window.innerWidth * this.scale, newHeight = window.innerHeight * this.scale;
          if (prevWidth === newWidth && prevHeight === newHeight)
            return;
          this.width = this.canvasElement.width = newWidth;
          this.height = this.canvasElement.height = newHeight;
          this.resizeHandler(prevWidth, prevHeight, newWidth, newHeight);
        }
        clear() {
          this.renderContext.fillStyle = this.renderBaseColor;
          this.renderContext.fillRect(0, 0, this.width, this.height);
        }
      };
    }
  });

  // src/components/CursorTranslateComponent.ts
  var CursorTranslate;
  var init_CursorTranslateComponent = __esm({
    "src/components/CursorTranslateComponent.ts"() {
      init_dist();
      CursorTranslate = fluidInternal.defineComponentType("Cursor Translate");
    }
  });

  // src/components/PositionComponent.ts
  var Position;
  var init_PositionComponent = __esm({
    "src/components/PositionComponent.ts"() {
      init_dist();
      Position = fluidInternal.defineComponentType("Position");
    }
  });

  // src/components/ScreenPointComponent.ts
  var ScreenPoint;
  var init_ScreenPointComponent = __esm({
    "src/components/ScreenPointComponent.ts"() {
      init_dist();
      ScreenPoint = fluidInternal.defineComponentType("Screen Point");
    }
  });

  // src/systems/simulation/CursorSystem.ts
  var schema, nodeMeta, CursorSystem;
  var init_CursorSystem = __esm({
    "src/systems/simulation/CursorSystem.ts"() {
      init_internal();
      init_dist();
      init_CursorTranslateComponent();
      init_PositionComponent();
      init_ScreenPointComponent();
      init_dist();
      schema = {
        position: Position,
        screenPoint: ScreenPoint,
        cursorTranslate: CursorTranslate
      };
      nodeMeta = fluidInternal.registerNodeSchema(schema, "Cursor Update");
      CursorSystem = class extends FluidSystem {
        constructor(engineInstance) {
          super("Cursor System", nodeMeta);
          this.engineInstance = engineInstance;
        }
        updateNode(node) {
          node.position.position = Vector2.add(
            node.cursorTranslate.cursorTranslate,
            Vector2.scale(node.screenPoint.point, 1 / this.engineInstance.PIXELS_PER_METER)
          );
        }
      };
    }
  });

  // src/components/FireControlComponent.ts
  var FireControl;
  var init_FireControlComponent = __esm({
    "src/components/FireControlComponent.ts"() {
      init_dist();
      FireControl = fluidInternal.defineComponentType("Fire Control");
    }
  });

  // src/components/ProjectileSourceComponent.ts
  var ProjectileSource;
  var init_ProjectileSourceComponent = __esm({
    "src/components/ProjectileSourceComponent.ts"() {
      init_dist();
      ProjectileSource = fluidInternal.defineComponentType("Projectile Source");
    }
  });

  // src/components/VelocityComponent.ts
  var Velocity;
  var init_VelocityComponent = __esm({
    "src/components/VelocityComponent.ts"() {
      init_dist();
      Velocity = fluidInternal.defineComponentType("Velocity");
    }
  });

  // src/systems/simulation/FiringSystem.ts
  var schema2, nodeMeta2, FiringSystem;
  var init_FiringSystem = __esm({
    "src/systems/simulation/FiringSystem.ts"() {
      init_internal();
      init_FireControlComponent();
      init_PositionComponent();
      init_ProjectileSourceComponent();
      init_VelocityComponent();
      init_dist();
      schema2 = {
        position: Position,
        velocity: Velocity,
        projectileSource: ProjectileSource,
        fireControl: FireControl
      };
      nodeMeta2 = fluidInternal.registerNodeSchema(schema2, "Firing");
      FiringSystem = class extends FluidSystem {
        constructor(engineInstance, spawnProjectile2) {
          super("Firing System", nodeMeta2);
          this.engineInstance = engineInstance;
          this.spawnProjectile = spawnProjectile2;
        }
        updateNode(node) {
          const GAME_TIME = this.engineInstance.getGameTime();
          const {
            fireControl,
            projectileSource,
            position: sourcePositionComponent,
            velocity: sourceVelocityComponent
          } = node;
          const {
            position: sourcePositionVector,
            rotation: sourceRotation
          } = sourcePositionComponent;
          const {
            velocity: sourceVelocity,
            angular: sourceAngularVelocity
          } = sourceVelocityComponent;
          const {
            muzzleSpeed,
            projectileWidth,
            projectileType,
            fireRate,
            transform: sourceTransform
          } = projectileSource;
          if (!fireControl.fireIntent)
            return;
          if (GAME_TIME - projectileSource.lastFireTime < 1 / fireRate)
            return;
          let projectileRotation = sourceRotation;
          if (sourceTransform?.rotate !== void 0)
            projectileRotation += sourceTransform.rotate;
          const projectileDirectionX = Math.cos(projectileRotation);
          const projectileDirectionY = Math.sin(projectileRotation);
          const projectileInitialStep = sourceTransform?.scale || 0;
          const projectileMuzzleOffsetX = projectileDirectionX * projectileInitialStep;
          const projectileMuzzleOffsetY = projectileDirectionY * projectileInitialStep;
          let projectilePositionX = sourcePositionVector.x;
          let projectilePositionY = sourcePositionVector.y;
          const sourceTranslate = sourceTransform?.translate;
          if (sourceTranslate) {
            projectilePositionX += sourceTranslate.x;
            projectilePositionY += sourceTranslate.y;
          }
          const projectilePosition = {
            x: projectilePositionX + projectileMuzzleOffsetX,
            y: projectilePositionY + projectileMuzzleOffsetY
          };
          const muzzleTangentVectorX = -projectileMuzzleOffsetY;
          const muzzleTangentVectorY = projectileMuzzleOffsetX;
          const tangentialVelocityX = sourceAngularVelocity * muzzleTangentVectorX;
          const tangentialVelocityY = sourceAngularVelocity * muzzleTangentVectorY;
          const projectileVelocity = {
            x: sourceVelocity.x + tangentialVelocityX + projectileDirectionX * muzzleSpeed,
            y: sourceVelocity.y + tangentialVelocityY + projectileDirectionY * muzzleSpeed
          };
          const spID = this.spawnProjectile({
            position: projectilePosition,
            velocity: projectileVelocity,
            rotation: sourceRotation,
            angularVelocity: 0,
            type: projectileType,
            width: projectileWidth,
            spawnTime: GAME_TIME,
            generation: 1
          });
          if (!spID)
            console.warn("Failed to spawn projectile!");
          projectileSource.lastFireTime = GAME_TIME;
        }
      };
    }
  });

  // src/components/AccelerationComponent.ts
  var Acceleration;
  var init_AccelerationComponent = __esm({
    "src/components/AccelerationComponent.ts"() {
      init_dist();
      Acceleration = fluidInternal.defineComponentType("Acceleration");
    }
  });

  // src/systems/simulation/KinematicSystem.ts
  var schema3, nodeMeta3, KinematicSystem;
  var init_KinematicSystem = __esm({
    "src/systems/simulation/KinematicSystem.ts"() {
      init_dist();
      init_internal();
      init_AccelerationComponent();
      init_PositionComponent();
      init_VelocityComponent();
      schema3 = {
        position: Position,
        velocity: Velocity,
        acceleration: Acceleration
      };
      nodeMeta3 = fluidInternal.registerNodeSchema(schema3, "Kinematic");
      KinematicSystem = class extends FluidSystem {
        constructor(clientContext) {
          super("Kinematic System", nodeMeta3);
          this.clientContext = clientContext;
        }
        updateNode(node) {
          const DELTA_TIME = this.clientContext.engineInstance.getDeltaTime();
          const { velocity: velocityComp, acceleration: accelerationComp } = node;
          const a = accelerationComp.acceleration, v = velocityComp.velocity;
          v.x += a.x * DELTA_TIME;
          v.y += a.y * DELTA_TIME;
          velocityComp.angular += accelerationComp.angular * DELTA_TIME;
        }
      };
    }
  });

  // src/components/MovementControlComponent.ts
  var MovementControl;
  var init_MovementControlComponent = __esm({
    "src/components/MovementControlComponent.ts"() {
      init_dist();
      MovementControl = fluidInternal.defineComponentType("Movement Control");
    }
  });

  // src/components/ThrusterComponent.ts
  var Thruster;
  var init_ThrusterComponent = __esm({
    "src/components/ThrusterComponent.ts"() {
      init_dist();
      Thruster = fluidInternal.defineComponentType("Thruster");
    }
  });

  // src/components/PhysicsComponent.ts
  var Physics;
  var init_PhysicsComponent = __esm({
    "src/components/PhysicsComponent.ts"() {
      init_dist();
      Physics = fluidInternal.defineComponentType("Physics");
    }
  });

  // src/systems/simulation/MovementControlSystem.ts
  function clamp(value, min, max) {
    if (value < min)
      return min;
    if (value > max)
      return max;
    return value;
  }
  function computeAcceleration(inputMultiplier, speed, maxAcceleration, maxSpeed, accelerationCurveControlFactor) {
    if (inputMultiplier === 0) return 0;
    inputMultiplier = clamp(inputMultiplier, -1, 1);
    maxSpeed = Math.abs(inputMultiplier) * maxSpeed;
    speed = clamp(speed, -maxSpeed, maxSpeed);
    accelerationCurveControlFactor = clamp(accelerationCurveControlFactor, -0.9, 10);
    const targetSpeed = inputMultiplier * maxSpeed;
    const speedDelta = targetSpeed - speed;
    const normalizedDelta = speedDelta / (2 * maxSpeed);
    const accelLin = normalizedDelta * maxAcceleration;
    const curveControlBase = round2(Math.abs(speedDelta) == 0 ? 1 : Math.abs(normalizedDelta), 1);
    const accel = curveControlBase ** accelerationCurveControlFactor * accelLin;
    return clamp(accel, -maxAcceleration, maxAcceleration);
  }
  function applyLinearTransformationMatrixToVector(matrix_i_x, matrix_i_y, matrix_j_x, matrix_j_y, vector_x, vector_y, out = { x: 0, y: 0 }, { decimalPlaces = 5 } = {}) {
    out.x = round2(vector_x * matrix_i_x + vector_y * matrix_j_x, decimalPlaces);
    out.y = round2(vector_x * matrix_i_y + vector_y * matrix_j_y, decimalPlaces);
    return out;
  }
  function transformRealLocalVectorToWorldSpace(vector_x, vector_y, sin, cos, out) {
    return applyLinearTransformationMatrixToVector(
      -sin,
      cos,
      cos,
      sin,
      vector_x,
      vector_y,
      out
    );
  }
  var round2, schema4, nodeMeta4, DefaultMovementControlParameters, inputComponentMultiplierLookup, MovementControlSystem;
  var init_MovementControlSystem = __esm({
    "src/systems/simulation/MovementControlSystem.ts"() {
      init_dist();
      init_internal();
      init_AccelerationComponent();
      init_MovementControlComponent();
      init_PositionComponent();
      init_VelocityComponent();
      init_ThrusterComponent();
      init_PhysicsComponent();
      init_dist();
      round2 = MathUtils_exports.round;
      schema4 = {
        position: Position,
        velocity: Velocity,
        acceleration: Acceleration,
        thruster: Thruster,
        physics: Physics,
        movementControl: MovementControl
      };
      nodeMeta4 = fluidInternal.registerNodeSchema(schema4, "Movement Control");
      DefaultMovementControlParameters = {
        maxSpeed: 3 * Math.E,
        maxAngularSpeed: Math.PI,
        axialThrusterPowerCoefficient: 1,
        lateralThrusterPowerCoefficient: 0.8,
        angularThrusterPowerCoefficient: 0.85,
        axialStabilizationFactor: 0.25,
        lateralStabilizationFactor: 0.8,
        angularStabilizationFactor: 0.75,
        axialAccelerationCurveControlFactor: -0.6,
        angularAccelerationCurveControlFactor: -0.6
      };
      inputComponentMultiplierLookup = [
        // x = -1
        [
          // -1, -1
          Math.SQRT1_2,
          // -1, 0
          1,
          // -1, 1
          Math.SQRT1_2
        ],
        // x = 0
        [
          // 0, -1
          1,
          // 0, 0
          0,
          // 0, 1
          1
        ],
        // x = 1
        [
          // 1, -1
          Math.SQRT1_2,
          // 1, 0
          1,
          // 1, 1
          Math.SQRT1_2
        ]
      ];
      MovementControlSystem = class extends FluidSystem {
        constructor(getDeltaTime, motionParameters = DefaultMovementControlParameters) {
          super("Movement Control System", nodeMeta4);
          this.getDeltaTime = getDeltaTime;
          this.motionParameters = motionParameters;
        }
        updateNode(node) {
          const {
            maxSpeed,
            maxAngularSpeed,
            axialThrusterPowerCoefficient,
            lateralThrusterPowerCoefficient,
            angularThrusterPowerCoefficient,
            axialStabilizationFactor,
            lateralStabilizationFactor,
            angularStabilizationFactor,
            axialAccelerationCurveControlFactor,
            angularAccelerationCurveControlFactor
          } = this.motionParameters;
          const {
            velocity: velocityComponent,
            acceleration: accelerationComponent,
            movementControl: controlInput,
            physics,
            thruster
          } = node;
          const velocity = velocityComponent.velocity;
          const acceleration = accelerationComponent.acceleration;
          const accelerationInputFlag = controlInput.accelerationInput.x || controlInput.accelerationInput.y ? 1 : 0;
          const angularSpeed = velocityComponent.angular;
          const yawInputFlag = controlInput.yawInput;
          const inputComponentScale = inputComponentMultiplierLookup[controlInput.accelerationInput.x + 1][controlInput.accelerationInput.y + 1];
          const thrusterMaxAcceleration = thruster.maxForce / physics.mass;
          const rotation = node.position.rotation;
          const sin = Math.sin(rotation);
          const cos = Math.cos(rotation);
          accelerationComponent.angular = 0;
          acceleration.x = 0;
          acceleration.y = 0;
          const angularSpeedPercentage = angularSpeed / maxAngularSpeed;
          const yawControl = yawInputFlag || -angularSpeedPercentage;
          const angularAccelerationCoefficient = yawInputFlag ? 1 : Math.abs(angularSpeedPercentage) * angularStabilizationFactor;
          const angularAccelerationMagnitude = round2(
            computeAcceleration(
              yawControl,
              angularSpeed,
              thrusterMaxAcceleration * angularThrusterPowerCoefficient,
              maxAngularSpeed,
              angularAccelerationCurveControlFactor
            ),
            3
          );
          accelerationComponent.angular = angularAccelerationMagnitude * angularAccelerationCoefficient;
          const speed = Math.hypot(velocity.x, velocity.y);
          let accelerationControl = 0;
          let accelerationDirectionX = 0;
          let accelerationDirectionY = 0;
          let axialAccelerationCoefficient = 0;
          let lateralAccelerationCoefficient = 0;
          if (speed && !accelerationInputFlag) {
            let speedPercentage = speed / maxSpeed;
            accelerationControl = -speedPercentage;
            accelerationDirectionX = velocity.x / speed;
            accelerationDirectionY = velocity.y / speed;
            axialAccelerationCoefficient = speedPercentage * axialStabilizationFactor;
            lateralAccelerationCoefficient = speedPercentage * lateralStabilizationFactor;
          }
          if (accelerationInputFlag) {
            transformRealLocalVectorToWorldSpace(
              controlInput.accelerationInput.x * inputComponentScale,
              controlInput.accelerationInput.y * inputComponentScale,
              sin,
              cos,
              controlInput.accelerationInput
            );
            accelerationControl = accelerationInputFlag;
            accelerationDirectionX = controlInput.accelerationInput.x;
            accelerationDirectionY = controlInput.accelerationInput.y;
            axialAccelerationCoefficient = 1;
            lateralAccelerationCoefficient = 1;
          }
          if (speed || accelerationInputFlag) {
            const speedAlongAccelerationDirection = velocity.x * accelerationDirectionX + velocity.y * accelerationDirectionY;
            const accelerationMagnitude = round2(
              computeAcceleration(
                accelerationControl,
                speedAlongAccelerationDirection,
                thrusterMaxAcceleration,
                maxSpeed,
                axialAccelerationCurveControlFactor
              ),
              3
            );
            const accelerationX = accelerationMagnitude * accelerationDirectionX;
            const accelerationY = accelerationMagnitude * accelerationDirectionY;
            const axialAcceleration = axialAccelerationCoefficient * axialThrusterPowerCoefficient * (accelerationX * cos + accelerationY * sin);
            const axialAccelerationX = axialAcceleration * cos;
            const axialAccelerationY = axialAcceleration * sin;
            const lateralAcceleration = lateralAccelerationCoefficient * lateralThrusterPowerCoefficient * (accelerationX * -sin + accelerationY * cos);
            const lateralAccelerationX = lateralAcceleration * -sin;
            const lateralAccelerationY = lateralAcceleration * cos;
            acceleration.x = round2(axialAccelerationX + lateralAccelerationX, 3);
            acceleration.y = round2(axialAccelerationY + lateralAccelerationY, 3);
          }
          controlInput.yawInput = 0;
          controlInput.accelerationInput.x = 0;
          controlInput.accelerationInput.y = 0;
        }
      };
    }
  });

  // src/systems/simulation/PositionSystem.ts
  var PI3, PI22, schema5, nodeMeta5, PositionSystem;
  var init_PositionSystem = __esm({
    "src/systems/simulation/PositionSystem.ts"() {
      init_dist();
      init_internal();
      init_PositionComponent();
      init_VelocityComponent();
      PI3 = Math.PI;
      PI22 = 2 * PI3;
      schema5 = {
        position: Position,
        velocity: Velocity
      };
      nodeMeta5 = fluidInternal.registerNodeSchema(schema5, "Position");
      PositionSystem = class extends FluidSystem {
        constructor(engineInstance) {
          super("Position System", nodeMeta5);
          this.engineInstance = engineInstance;
        }
        updateNode(node) {
          const DELTA_TIME = this.engineInstance.deltaTime;
          const { position: posComp, velocity: velComp } = node;
          const { position: pos } = posComp;
          const { velocity: vel, angular: angVel } = velComp;
          let rot = posComp.rotation;
          pos.x += vel.x * DELTA_TIME;
          pos.y += vel.y * DELTA_TIME;
          rot += angVel * DELTA_TIME;
          if (rot >= PI3)
            rot -= PI22;
          if (rot < -PI3)
            rot += PI22;
          posComp.rotation = rot;
        }
      };
    }
  });

  // src/components/BoundingBoxComponent.ts
  function createBoundingBox(size, { center = Vector2.zero(), rotation = 0, transform = createTransform(), aabb = void 0, obb = void 0 } = {}) {
    return { center, rotation, size, transform, obb, aabb };
  }
  var BoundingBox;
  var init_BoundingBoxComponent = __esm({
    "src/components/BoundingBoxComponent.ts"() {
      init_dist();
      init_dist();
      BoundingBox = fluidInternal.defineComponentType("BoundingBox");
    }
  });

  // src/components/ChunkOccupancyComponent.ts
  var ChunkOccupancy;
  var init_ChunkOccupancyComponent = __esm({
    "src/components/ChunkOccupancyComponent.ts"() {
      init_dist();
      ChunkOccupancy = fluidInternal.defineComponentType("Chunk Occupancy");
    }
  });

  // src/components/CollisionComponent.ts
  var Collision;
  var init_CollisionComponent = __esm({
    "src/components/CollisionComponent.ts"() {
      init_dist();
      Collision = fluidInternal.defineComponentType("Collision");
    }
  });

  // src/systems/simulation/CollisionDetectionSystem.ts
  var schema6, nodeMeta6, CollisionDetectionSystem;
  var init_CollisionDetectionSystem = __esm({
    "src/systems/simulation/CollisionDetectionSystem.ts"() {
      init_dist();
      init_internal();
      init_dist();
      init_BoundingBoxComponent();
      init_ChunkOccupancyComponent();
      init_CollisionComponent();
      schema6 = {
        boundingBox: BoundingBox,
        chunks: ChunkOccupancy
      };
      nodeMeta6 = fluidInternal.registerNodeSchema(schema6, "Collision Detection");
      CollisionDetectionSystem = class extends FluidSystem {
        constructor(engineInstance) {
          super("Collision Detection System", nodeMeta6);
          this.engineInstance = engineInstance;
        }
        *clearCollisionComponent(nodes) {
          for (const node of nodes) {
            const entityId = node.entityId;
            if (fluidInternal.entityHasComponent(entityId, Collision))
              fluidInternal.removeEntityComponent(entityId, Collision);
            yield node;
          }
        }
        getEntitiesPerChunk(nodes) {
          const chunkMap = /* @__PURE__ */ new Map();
          for (const node of nodes) {
            if (!node.boundingBox.aabb)
              continue;
            const entityChunks = node.chunks.chunkKeys;
            const entitySymbol = node.entityId.getSymbol();
            for (const chunk of entityChunks) {
              let entityMap = chunkMap.get(chunk);
              if (!entityMap) {
                entityMap = /* @__PURE__ */ new Map();
                chunkMap.set(chunk, entityMap);
              }
              if (!entityMap.has(entitySymbol))
                entityMap.set(entitySymbol, node);
            }
          }
          return chunkMap.values().map((entityMap) => Array.from(entityMap.values()));
        }
        *sortAndSweep(groups) {
          for (const group of groups) {
            if (group.length <= 1)
              continue;
            group.sort(
              (nodeA, nodeB) => nodeA.boundingBox.aabb.minX - nodeB.boundingBox.aabb.minX
            );
            const groupSize = group.length;
            for (let i = 0; i < groupSize; i++) {
              const nodeA = group[i];
              const boundingBoxA = nodeA.boundingBox;
              for (let j = i + 1; j < groupSize; j++) {
                const nodeB = group[j];
                const boundingBoxB = nodeB.boundingBox;
                if (boundingBoxB.aabb.minX > boundingBoxA.aabb.maxX) break;
                yield [nodeA, nodeB];
              }
            }
          }
        }
        *checkCollision(candidatePairs) {
          for (const candidatePair of candidatePairs) {
            const nodeA = candidatePair[0];
            const nodeB = candidatePair[1];
            const boundingBoxA = nodeA.boundingBox;
            const boundingBoxB = nodeB.boundingBox;
            if (!aabbsIntersect(boundingBoxA.aabb, boundingBoxB.aabb))
              continue;
            if (!isSeparatingAxisExistent(boundingBoxA.obb.corners, boundingBoxB.obb.corners))
              yield [nodeA, nodeB];
          }
        }
        onCollide(nodeA, nodeB) {
          const eA = nodeA.entityId, eB = nodeB.entityId;
          const proxyA = fluidInternal.getEntityProxy(eA);
          const proxyB = fluidInternal.getEntityProxy(eB);
          if (!proxyA.hasComponent(Collision))
            proxyA.addComponent(Collision.createComponent({ collidedEntity: eB }));
          if (!proxyB.hasComponent(Collision))
            proxyB.addComponent(Collision.createComponent({ collidedEntity: eA }));
        }
        updateNodes(nodes) {
          const entityGroups = this.getEntitiesPerChunk(this.clearCollisionComponent(nodes));
          const candidates = this.sortAndSweep(entityGroups);
          const collided = this.checkCollision(candidates);
          for (const pair of collided) {
            this.onCollide(pair[0], pair[1]);
          }
        }
      };
    }
  });

  // src/components/CameraSpeedFactorComponent.ts
  var CameraSpeedFactor;
  var init_CameraSpeedFactorComponent = __esm({
    "src/components/CameraSpeedFactorComponent.ts"() {
      init_dist();
      CameraSpeedFactor = fluidInternal.defineComponentType("Camera Speed Factor");
    }
  });

  // src/components/ResolutionComponent.ts
  var Resolution;
  var init_ResolutionComponent = __esm({
    "src/components/ResolutionComponent.ts"() {
      init_dist();
      Resolution = fluidInternal.defineComponentType("Resolution");
    }
  });

  // src/components/TargetPositionComponent.ts
  var TargetPosition;
  var init_TargetPositionComponent = __esm({
    "src/components/TargetPositionComponent.ts"() {
      init_dist();
      TargetPosition = fluidInternal.defineComponentType("Target Position");
    }
  });

  // src/components/ViewportComponent.ts
  var Viewport;
  var init_ViewportComponent = __esm({
    "src/components/ViewportComponent.ts"() {
      init_dist();
      Viewport = fluidInternal.defineComponentType("Viewport");
    }
  });

  // src/systems/simulation/ViewportSystem.ts
  var shortestAngleDiff2, schema7, nodeMeta7, ViewportSystem;
  var init_ViewportSystem = __esm({
    "src/systems/simulation/ViewportSystem.ts"() {
      init_dist();
      init_internal();
      init_dist();
      init_CameraSpeedFactorComponent();
      init_PositionComponent();
      init_ResolutionComponent();
      init_TargetPositionComponent();
      init_ViewportComponent();
      shortestAngleDiff2 = MathUtils_exports.shortestAngleDiff;
      schema7 = {
        position: Position,
        resolution: Resolution,
        targetPosition: TargetPosition,
        speedFactor: CameraSpeedFactor,
        viewport: Viewport
      };
      nodeMeta7 = fluidInternal.registerNodeSchema(schema7, "Viewport");
      ViewportSystem = class extends FluidSystem {
        constructor(clientContext) {
          super("Viewport System", nodeMeta7);
          this.clientContext = clientContext;
        }
        updateNode(node) {
          const eng = this.clientContext.engineInstance;
          const DELTA_TIME = eng.getDeltaTime();
          const PPM = eng.PIXELS_PER_METER;
          const { position: positionComp, targetPosition: targetPositionComp, speedFactor: speedFactorComp, resolution: resolutionComp } = node;
          const { position: pos, rotation: rot } = positionComp;
          const { position: tPos, rotation: tRot } = targetPositionComp.position;
          const vpRes = resolutionComp.resolution;
          const step = speedFactorComp.speedFactor * DELTA_TIME;
          const centerPos = Vector2.add(pos, { x: vpRes.x / (2 * PPM), y: vpRes.y / (2 * PPM) });
          const diff = Vector2.subtract(tPos, centerPos);
          const dist = Vector2.abs(diff);
          const moveDir = Vector2.normalize(diff);
          if (dist.x > 0 || dist.y > 0) {
            const moveVec = Vector2.multiply(moveDir, dist);
            const stepVec = Vector2.scale(moveVec, step);
            positionComp.position = Vector2.add(pos, stepVec);
          }
          if (rot != tRot) {
            const angleDiff = shortestAngleDiff2(rot, tRot);
            positionComp.rotation = rot + angleDiff * step;
          }
        }
      };
    }
  });

  // src/components/ProjectileComponent.ts
  var Projectile;
  var init_ProjectileComponent = __esm({
    "src/components/ProjectileComponent.ts"() {
      init_dist();
      Projectile = fluidInternal.defineComponentType("Projectile");
    }
  });

  // src/systems/simulation/ProjectileSystem.ts
  var schema8, nodeMeta8, ProjectileSystem;
  var init_ProjectileSystem = __esm({
    "src/systems/simulation/ProjectileSystem.ts"() {
      init_dist();
      init_internal();
      init_PositionComponent();
      init_ProjectileComponent();
      schema8 = {
        projectile: Projectile,
        position: Position
      };
      nodeMeta8 = fluidInternal.registerNodeSchema(schema8, "Projectile");
      ProjectileSystem = class extends FluidSystem {
        constructor(engineInstance) {
          super("Projectile System", nodeMeta8);
          this.engineInstance = engineInstance;
        }
        updateNode(node) {
          const eng = this.engineInstance;
          const GAME_TIME = eng.getGameTime();
          if (GAME_TIME >= node.projectile.deathTime) {
            fluidInternal.removeEntity(node.entityId);
          }
        }
      };
    }
  });

  // src/systems/simulation/BoundingBoxUpdateSystem.ts
  var fcos, fsin, abs, schema9, nodeMeta9, BoundingBoxUpdateSystem;
  var init_BoundingBoxUpdateSystem = __esm({
    "src/systems/simulation/BoundingBoxUpdateSystem.ts"() {
      init_dist();
      init_internal();
      init_dist();
      init_BoundingBoxComponent();
      init_PositionComponent();
      fcos = Math.cos;
      fsin = Math.sin;
      abs = Math.abs;
      schema9 = {
        position: Position,
        boundingBox: BoundingBox
      };
      nodeMeta9 = fluidInternal.registerNodeSchema(schema9, "Bounding Box Update");
      BoundingBoxUpdateSystem = class extends FluidSystem {
        constructor() {
          super("Bounding Box Update System", nodeMeta9);
        }
        updateNode(node) {
          const { position: posComp, boundingBox: bb } = node;
          const { center } = bb;
          const eP = posComp.position;
          const size = bb.size;
          bb.rotation = posComp.rotation;
          center.x = eP.x;
          center.y = eP.y;
          const transform = bb.transform;
          if (transform) {
            const { scale, rotate, translate } = transform;
            if (scale) {
              size.width *= scale;
              size.height *= scale;
              transform.scale = void 0;
            }
            if (rotate) {
              bb.rotation += rotate;
            }
            if (translate) {
              center.x += translate.x;
              center.y += translate.y;
            }
          }
          const { x: cx, y: cy } = center;
          const rot = bb.rotation;
          const cos = fcos(rot), sin = fsin(rot);
          const hw2 = size.width / 2, hh2 = size.height / 2;
          const dX = abs(hw2 * cos) + abs(hh2 * sin);
          const dY = abs(hw2 * sin) + abs(hh2 * cos);
          const aabb = bb.aabb || {};
          aabb.minX = cx - dX;
          aabb.maxX = cx + dX;
          aabb.maxY = cy + dY;
          aabb.minY = cy - dY;
          bb.aabb = aabb;
          const axisX = { x: cos, y: sin };
          const axisY = { x: -sin, y: cos };
          const obb = bb.obb || createOBB();
          obb.halfExtents.x = hw2;
          obb.halfExtents.y = hh2;
          obb.axes.x = axisX;
          obb.axes.y = axisY;
          const dx = [hw2, hw2, -hw2, -hw2];
          const dy = [hh2, -hh2, -hh2, hh2];
          for (let i = 0; i < 4; i++) {
            const offsetX = dx[i] * axisX.x + dy[i] * axisY.x;
            const offsetY = dx[i] * axisX.y + dy[i] * axisY.y;
            obb.corners[i].x = cx + offsetX;
            obb.corners[i].y = cy + offsetY;
          }
          bb.obb = obb;
        }
      };
    }
  });

  // src/components/RenderCenterComponent.ts
  var RenderCenter;
  var init_RenderCenterComponent = __esm({
    "src/components/RenderCenterComponent.ts"() {
      init_dist();
      RenderCenter = fluidInternal.defineComponentType("Render Center");
    }
  });

  // src/systems/simulation/chunk/ChunkLoadingSystem.ts
  var schema10, nodeMeta10, ChunkLoadingSystem;
  var init_ChunkLoadingSystem = __esm({
    "src/systems/simulation/chunk/ChunkLoadingSystem.ts"() {
      init_internal();
      init_dist();
      init_PositionComponent();
      init_RenderCenterComponent();
      schema10 = {
        renderCenter: RenderCenter,
        position: Position
      };
      nodeMeta10 = fluidInternal.registerNodeSchema(schema10, "Chunk Loading");
      ChunkLoadingSystem = class extends FluidSystem {
        constructor(engineInstance, worldContext) {
          super("Chunk Loading System", nodeMeta10);
          this.engineInstance = engineInstance;
          this.worldContext = worldContext;
        }
        updateNode(node) {
          const worldContext = this.worldContext;
          const chunkSize = worldContext.chunkSize;
          const gameTime = this.engineInstance.getGameTime();
          const renderCenterPos = node.position.position, renderDistance = node.renderCenter.renderDistance;
          const [ci, cj] = getChunkIndexFromPosition(renderCenterPos, chunkSize);
          const renderDistanceInChunks = Math.ceil(renderDistance / chunkSize);
          for (let i = -renderDistanceInChunks; i <= renderDistanceInChunks; i++)
            for (let j = -renderDistanceInChunks; j <= renderDistanceInChunks; j++) {
              const idxX = ci + i, idxY = cj + j;
              const chunkKey = getChunkKeyFromIndex(idxX, idxY);
              let chunk = worldContext.getChunk(chunkKey);
              if (!chunk || chunk.state == ChunkState.Unloaded) {
                try {
                  chunk = worldContext.loadChunk(chunkKey);
                } catch (error) {
                  console.error(`Failed to load chunk (chunk: ${chunkKey})`, error);
                  continue;
                }
              }
              chunk.lastAccessed = gameTime;
            }
        }
      };
    }
  });

  // src/components/ChunkComponent.ts
  var Chunk;
  var init_ChunkComponent = __esm({
    "src/components/ChunkComponent.ts"() {
      init_dist();
      Chunk = fluidInternal.defineComponentType("Chunk");
    }
  });

  // src/systems/simulation/chunk/ChunkUnloadingSystem.ts
  var schema11, nodeMeta11, ChunkUnloadingSystem;
  var init_ChunkUnloadingSystem = __esm({
    "src/systems/simulation/chunk/ChunkUnloadingSystem.ts"() {
      init_internal();
      init_dist();
      init_ChunkComponent();
      schema11 = {
        chunk: Chunk
      };
      nodeMeta11 = fluidInternal.registerNodeSchema(schema11, "Chunk Unloading");
      ChunkUnloadingSystem = class extends FluidSystem {
        constructor(engineInstance, worldContext) {
          super("Chunk Unloading System", nodeMeta11);
          this.engineInstance = engineInstance;
          this.worldContext = worldContext;
        }
        updateNode(node) {
          const worldContext = this.worldContext;
          const { chunkTimeout } = this.worldContext;
          const gameTime = this.engineInstance.getGameTime();
          const chunk = node.chunk.chunk;
          if (chunk.state == ChunkState.Loaded && gameTime - chunk.lastAccessed >= chunkTimeout)
            try {
              worldContext.unloadChunk(chunk.key);
            } catch (error) {
              console.error(`Failed to unload chunk#${chunk.key}}:`, error);
            }
        }
      };
    }
  });

  // src/systems/simulation/chunk/ChunkOccupancyUpdateSystem.ts
  var conservativeOBBRasterization2, schema12, nodeMeta12, ChunkOccupancyUpdateSystem;
  var init_ChunkOccupancyUpdateSystem = __esm({
    "src/systems/simulation/chunk/ChunkOccupancyUpdateSystem.ts"() {
      init_internal();
      init_dist();
      init_BoundingBoxComponent();
      init_ChunkOccupancyComponent();
      conservativeOBBRasterization2 = GridUtils_exports.conservativeOBBRasterization;
      schema12 = {
        boundingBox: BoundingBox,
        chunks: ChunkOccupancy
      };
      nodeMeta12 = fluidInternal.registerNodeSchema(schema12, "Chunk Occupancy Update");
      ChunkOccupancyUpdateSystem = class extends FluidSystem {
        constructor(engineInstance, worldContext) {
          super("Chunk Occupancy Update System", nodeMeta12);
          this.engineInstance = engineInstance;
          this.worldContext = worldContext;
        }
        updateNode(node) {
          const { boundingBox: bb, chunks: entityChunksComp, entityId } = node;
          const entityChunkKeys = entityChunksComp.chunkKeys;
          const { aabb, obb, size, center } = bb;
          const { width: width2, height: height2 } = size;
          const wc = this.worldContext;
          const chunkSize = wc.chunkSize;
          if (!obb && !aabb) return;
          let currentChunkKeys = /* @__PURE__ */ new Set();
          if (obb) {
            conservativeOBBRasterization2(
              width2,
              height2,
              chunkSize,
              1.15,
              1.15,
              obb.axes,
              center,
              3,
              (i, j) => {
                currentChunkKeys.add(getChunkKeyFromIndex(i, j));
              }
            );
          } else if (aabb) {
            const { minX: left, maxX: right, minY: bottom, maxY: top } = aabb;
            const corners = [
              { x: left, y: bottom },
              { x: right, y: bottom },
              { x: right, y: top },
              { x: left, y: top }
            ];
            for (const v of corners) {
              const [i, j] = getChunkIndexFromPosition(v, chunkSize);
              currentChunkKeys.add(getChunkKeyFromIndex(i, j));
            }
          }
          if (currentChunkKeys.size == 0) return;
          if (entityChunkKeys.size === currentChunkKeys.size && [...entityChunkKeys].every((k) => currentChunkKeys.has(k)))
            return;
          const toAdd = /* @__PURE__ */ new Set();
          const toRemove = /* @__PURE__ */ new Set();
          let unloadEntity = true;
          for (const chunkKey of currentChunkKeys) {
            if (wc.getChunk(chunkKey)?.state === ChunkState.Loaded)
              unloadEntity = false;
            if (!entityChunkKeys.has(chunkKey)) {
              toAdd.add(chunkKey);
            }
          }
          for (const chunkKey of entityChunkKeys) {
            if (!currentChunkKeys.has(chunkKey)) {
              toRemove.add(chunkKey);
            }
          }
          entityChunksComp.chunkKeys = currentChunkKeys;
          for (const chunkKey of toAdd) {
            wc.getChunk(chunkKey)?.entitySymbolSet.add(entityId.getSymbol());
          }
          for (const chunkKey of toRemove) {
            wc.getChunk(chunkKey)?.entitySymbolSet.delete(entityId.getSymbol());
          }
          if (unloadEntity) {
            for (const chunkKey of currentChunkKeys)
              wc.unloadEntity(entityId, chunkKey);
          }
        }
      };
    }
  });

  // src/systems/simulation/chunk/index.ts
  var init_chunk = __esm({
    "src/systems/simulation/chunk/index.ts"() {
      init_ChunkLoadingSystem();
      init_ChunkUnloadingSystem();
      init_ChunkOccupancyUpdateSystem();
    }
  });

  // src/systems/render/WorldPreRenderSystem.ts
  var hPI2, schema13, nodeMeta13, WorldPreRenderSystem;
  var init_WorldPreRenderSystem = __esm({
    "src/systems/render/WorldPreRenderSystem.ts"() {
      init_dist();
      init_internal();
      init_PositionComponent();
      init_ResolutionComponent();
      init_ViewportComponent();
      hPI2 = Math.PI / 2;
      schema13 = {
        position: Position,
        resolution: Resolution,
        viewport: Viewport
      };
      nodeMeta13 = fluidInternal.registerNodeSchema(schema13, "World Pre Render");
      WorldPreRenderSystem = class extends FluidSystem {
        constructor(clientContext) {
          super("World Pre Render System", nodeMeta13);
          this.clientContext = clientContext;
        }
        updateNode(node) {
          const renderer = this.clientContext.renderer;
          const ctx = renderer.renderContext;
          const PPM = this.clientContext.engineInstance.PIXELS_PER_METER;
          const { position: vpPosComp, resolution: resolutionComponent } = node;
          const vpPos = vpPosComp.position;
          const resolution = resolutionComponent.resolution;
          const hW = resolution.x / (2 * PPM), hH = resolution.y / (2 * PPM);
          renderer.clear();
          ctx.save();
          ctx.scale(PPM, PPM);
          ctx.translate(hW, hH);
          ctx.rotate(-vpPosComp.rotation - hPI2);
          ctx.translate(-hW - vpPos.x, -hH - vpPos.y);
        }
      };
    }
  });

  // src/components/ViewportBorderWidthComponent.ts
  var ViewportBorderWidth;
  var init_ViewportBorderWidthComponent = __esm({
    "src/components/ViewportBorderWidthComponent.ts"() {
      init_dist();
      ViewportBorderWidth = fluidInternal.defineComponentType("Viewport Border Width");
    }
  });

  // src/systems/render/ViewportRenderSystem.ts
  var schema14, nodeMeta14, ViewportRenderSystem;
  var init_ViewportRenderSystem = __esm({
    "src/systems/render/ViewportRenderSystem.ts"() {
      init_dist();
      init_internal();
      init_ResolutionComponent();
      init_ViewportBorderWidthComponent();
      init_ViewportComponent();
      schema14 = {
        resolution: Resolution,
        borderWidth: ViewportBorderWidth,
        viewport: Viewport
      };
      nodeMeta14 = fluidInternal.registerNodeSchema(schema14, "Viewport Render");
      ViewportRenderSystem = class extends FluidSystem {
        constructor(renderContext) {
          super("Viewport Render System", nodeMeta14);
          this.renderContext = renderContext;
        }
        updateNode(node) {
          const ctx = this.renderContext;
          const isActive = true;
          if (!isActive)
            return;
          let borderWidth = node.borderWidth.borderWidth;
          let vWidth = node.resolution.resolution.x, vHeight = node.resolution.resolution.y;
          let darkShade = "rgba(0,0,0,1)", transparentShade = "rgba(0,0,0,0)";
          let wCS1 = borderWidth / vWidth;
          let grad = ctx.createLinearGradient(0, 0, vWidth, 0);
          grad.addColorStop(0, darkShade);
          grad.addColorStop(wCS1, transparentShade);
          grad.addColorStop(1 - wCS1, transparentShade);
          grad.addColorStop(1, darkShade);
          ctx.fillStyle = grad;
          ctx.fillRect(0, 0, vWidth, vHeight);
          let hCS1 = borderWidth / vHeight;
          grad = ctx.createLinearGradient(0, 0, 0, vHeight);
          grad.addColorStop(0, darkShade);
          grad.addColorStop(hCS1, transparentShade);
          grad.addColorStop(1 - hCS1, transparentShade);
          grad.addColorStop(1, darkShade);
          ctx.fillStyle = grad;
          ctx.fillRect(0, 0, vWidth, vHeight);
        }
      };
    }
  });

  // src/components/StatsComponent.ts
  var Stats;
  var init_StatsComponent = __esm({
    "src/components/StatsComponent.ts"() {
      init_dist();
      Stats = fluidInternal.defineComponentType("Stats");
    }
  });

  // src/Utils.ts
  function calculateRectangleMomentOfInertia(mass, width2, height2) {
    return 1 / 12 * mass * (width2 * width2 + height2 * height2);
  }
  function transformScaleLerpBulge(from, to, timeElapsed, totalDuration) {
    return {
      scale: MathUtils_exports.lerp(from.scale, to.scale, Math.sin(Math.PI * timeElapsed / totalDuration))
    };
  }
  function drawComplexText(renderContext, x, y, content = [["Colored ", "red"], ["\n"], ["Text ", "Blue"], ["Test", "Green"]], lineSpacing = 2) {
    const TEXT_METRICS = renderContext.measureText("A");
    const FONT_HEIGHT = TEXT_METRICS.actualBoundingBoxAscent + TEXT_METRICS.actualBoundingBoxDescent;
    let xOrig = x;
    for (const piece of content) {
      let text = piece[0];
      let color2 = piece.length > 1 ? piece[1] : renderContext.fillStyle;
      renderContext.fillStyle = color2;
      if (text.includes("\n")) {
        for (const line of text.split("\n")) {
          renderContext.fillText(line, x, y);
          y += FONT_HEIGHT + lineSpacing;
          x = xOrig;
        }
      } else {
        renderContext.fillText(text, x, y);
        x += renderContext.measureText(text).width;
      }
    }
    return y;
  }
  var init_Utils = __esm({
    "src/Utils.ts"() {
      init_dist();
    }
  });

  // src/systems/render/debug/DebugInfoDisplaySystem.ts
  var round3, schema15, nodeMeta15, DebugInfoDisplaySystem;
  var init_DebugInfoDisplaySystem = __esm({
    "src/systems/render/debug/DebugInfoDisplaySystem.ts"() {
      init_dist();
      init_internal();
      init_dist();
      init_AccelerationComponent();
      init_PositionComponent();
      init_StatsComponent();
      init_VelocityComponent();
      init_Utils();
      round3 = MathUtils_exports.round;
      schema15 = {
        position: Position,
        velocity: Velocity,
        acceleration: Acceleration,
        stats: Stats
      };
      nodeMeta15 = fluidInternal.registerNodeSchema(schema15, "Debug Info Display");
      DebugInfoDisplaySystem = class _DebugInfoDisplaySystem extends FluidSystem {
        constructor(clientContext) {
          super("Debug Info Display System", nodeMeta15);
          this.clientContext = clientContext;
        }
        stats = {
          isAnimating: (node) => this.clientContext.engineInstance.getAnimationState(),
          fps: (node) => round3(this.clientContext.engineInstance.getFPS()),
          position: (node) => {
            const pC = node.position;
            const { position: p, rotation: r } = pC;
            return `([${round3(p.x)}, ${round3(p.y)}] m) (${round3(r)} rad)`;
          },
          velocity: (node) => {
            const vC = node.velocity;
            const { velocity: v, angular: a } = vC;
            return `(${round3(Vector2.magnitude(v))} m/s) (${round3(a)} rad/s) ([${round3(v.x)}, ${round3(v.y)}] m/s)`;
          },
          acceleration: (node) => {
            const aC = node.acceleration;
            const { acceleration: accel, angular: angl } = aC;
            return `(${round3(Vector2.magnitude(accel))} m/s^2) (${round3(angl)} rad/s^2) ([${round3(accel.x)}, ${round3(accel.y)}] m/s^2)`;
          },
          zoom: () => {
            return `%${round3(this.clientContext.getZoomLevel())}`;
          },
          time: () => {
            return `x${round3(this.clientContext.getSimulationSpeed(), 5)}`;
          }
        };
        static formatStats(key, value) {
          return [`${key}: ${typeof value === "number" ? round3(value) : value}
`, "white"];
        }
        updateNode(node) {
          const cc = this.clientContext, stats = this.stats;
          if (!cc.displayDebugInfo)
            return;
          drawComplexText(
            cc.renderer.renderContext,
            10,
            10,
            Object.keys(stats).map(
              (key) => _DebugInfoDisplaySystem.formatStats(key, stats[key](node))
            ),
            2
          );
        }
      };
    }
  });

  // src/components/SpriteComponent.ts
  var Sprite;
  var init_SpriteComponent = __esm({
    "src/components/SpriteComponent.ts"() {
      init_dist();
      Sprite = fluidInternal.defineComponentType("Sprite");
    }
  });

  // src/systems/render/SpriteRenderSystem.ts
  var schema16, nodeMeta16, SpriteRenderSystem;
  var init_SpriteRenderSystem = __esm({
    "src/systems/render/SpriteRenderSystem.ts"() {
      init_dist();
      init_internal();
      init_PositionComponent();
      init_SpriteComponent();
      schema16 = {
        position: Position,
        spriteTexture: Sprite
      };
      nodeMeta16 = fluidInternal.registerNodeSchema(schema16, "Sprite Render");
      SpriteRenderSystem = class extends FluidSystem {
        constructor(canvasRenderer) {
          super("Sprite Render System", nodeMeta16);
          this.canvasRenderer = canvasRenderer;
        }
        updateNodes(nodes) {
          const sortedNodes = Array.from(nodes).sort(
            (a, b) => a.spriteTexture.zIndex - b.spriteTexture.zIndex
          );
          for (const { position, spriteTexture: sprite } of sortedNodes) {
            this.renderSprite(
              sprite,
              position.position.x,
              position.position.y,
              position.rotation
            );
          }
        }
        renderSprite(sprite, x, y, rotation) {
          const ctx = this.canvasRenderer.renderContext;
          const { renderSize: { x: width2, y: height2 }, transform, image } = sprite;
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(rotation);
          if (transform) {
            if (transform.rotate) ctx.rotate(transform.rotate);
            if (transform.translate) ctx.translate(transform.translate.x, transform.translate.y);
            if (transform.scale) ctx.scale(transform.scale, transform.scale);
          }
          ctx.scale(width2 / image.width, height2 / image.height);
          ctx.drawImage(image, -image.width / 2, -image.height / 2);
          ctx.restore();
        }
      };
    }
  });

  // src/systems/render/debug/BoundingBoxRenderSystem.ts
  var PI4, nodeSchema, nodeMeta17, BoundingBoxRenderSystem;
  var init_BoundingBoxRenderSystem = __esm({
    "src/systems/render/debug/BoundingBoxRenderSystem.ts"() {
      init_dist();
      init_internal();
      init_BoundingBoxComponent();
      PI4 = Math.PI;
      nodeSchema = {
        boundingBox: BoundingBox
      };
      nodeMeta17 = fluidInternal.registerNodeSchema(nodeSchema, "Bounding Box Render");
      BoundingBoxRenderSystem = class extends FluidSystem {
        constructor(clientContext) {
          super("Bounding Box Render System", nodeMeta17);
          this.clientContext = clientContext;
        }
        updateNode(node) {
          const client = this.clientContext;
          const PPM = client.engineInstance.PIXELS_PER_METER;
          if (!client.displayBoundingBoxes)
            return;
          const { boundingBox: bb } = node;
          const { width: width2, height: height2 } = bb.size;
          const ctx = this.clientContext.renderer.renderContext;
          ctx.save();
          ctx.lineWidth = 1 / PPM;
          ctx.strokeStyle = "white";
          const aabb = bb.aabb;
          if (aabb) {
            const { maxY, minY, minX, maxX } = aabb;
            ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);
          }
          const obb = bb.obb;
          if (obb && obb.corners) {
            const corners = obb.corners;
            ctx.beginPath();
            let corner = corners[0];
            ctx.moveTo(corner.x, corner.y);
            for (let i = 1; i < 4; i++) {
              corner = corners[i];
              ctx.lineTo(corner.x, corner.y);
            }
            ctx.closePath();
            ctx.stroke();
          }
          ctx.fillStyle = "white";
          ctx.beginPath();
          const centerPointWidth = Math.min(width2, height2) / 20;
          const hcpw = centerPointWidth / 2;
          const ctr = bb.center;
          ctx.arc(ctr.x, ctr.y, hcpw, 0, 2 * PI4);
          ctx.fill();
          ctx.fillStyle = "yellow";
          ctx.beginPath();
          ctx.arc(bb.aabb.maxX, ctr.y, hcpw, 0, 2 * PI4);
          ctx.fill();
          ctx.fillStyle = "green";
          ctx.beginPath();
          ctx.arc(ctr.x, bb.aabb.maxY, hcpw, 0, 2 * PI4);
          ctx.fill();
          ctx.restore();
        }
      };
    }
  });

  // src/systems/render/debug/AxisRenderSystem.ts
  var PI5, PI23, backgroundOverlayRenderColor, backgroundOverlayAlpha, alignedAxisScaleFactor, alignedAxisThicknessFactor, alignedAxisRenderColor, orientedAxisScaleFactor, orientedAxisThicknessFactor, orientedAxisRenderColor, rotationAngleArcRadiusFactor, rotationAngleArcColor, nodeMeta18, AxisRenderSystem;
  var init_AxisRenderSystem = __esm({
    "src/systems/render/debug/AxisRenderSystem.ts"() {
      init_dist();
      init_internal();
      init_BoundingBoxComponent();
      init_PositionComponent();
      PI5 = Math.PI;
      PI23 = 2 * PI5;
      backgroundOverlayRenderColor = "black";
      backgroundOverlayAlpha = 0.7;
      alignedAxisScaleFactor = 1.5;
      alignedAxisThicknessFactor = 2;
      alignedAxisRenderColor = "white";
      orientedAxisScaleFactor = 1.2;
      orientedAxisThicknessFactor = 1.25;
      orientedAxisRenderColor = "red";
      rotationAngleArcRadiusFactor = 0.25;
      rotationAngleArcColor = "yellow";
      nodeMeta18 = fluidInternal.registerNodeSchema(
        {
          position: Position,
          boundingBox: BoundingBox
        },
        "Axis Render"
      );
      AxisRenderSystem = class extends FluidSystem {
        constructor(clientContext) {
          super("Axis Render System", nodeMeta18);
          this.clientContext = clientContext;
        }
        updateNode(node) {
          if (!this.clientContext.displayEntityAxes)
            return;
          const { position: ePos, rotation: eRot } = node.position;
          const { size: bbRect, transform: bbTransform } = node.boundingBox;
          const width2 = bbRect.width, height2 = bbRect.height;
          const ctx = this.clientContext.renderer.renderContext;
          const PPM = this.clientContext.engineInstance.PIXELS_PER_METER;
          let rot = eRot, rotOffset = 0;
          ctx.save();
          ctx.translate(ePos.x, ePos.y);
          if (bbTransform) {
            const bbTranslate = bbTransform.translate, bbScale = bbTransform.scale, bbRot = bbTransform.rotate;
            if (bbTranslate) ctx.translate(bbTranslate.x, bbTranslate.y);
            if (bbScale) ctx.scale(bbScale, bbScale);
            if (bbRot) {
              rotOffset = bbRot;
            }
            ;
          }
          const length = Math.max(width2, height2) / 2;
          ctx.globalAlpha = backgroundOverlayAlpha;
          ctx.beginPath();
          ctx.arc(0, 0, length, 0, PI23);
          ctx.fillStyle = backgroundOverlayRenderColor;
          ctx.fill();
          ctx.globalAlpha = 1;
          const axisAlignedLength = alignedAxisScaleFactor * length;
          ctx.strokeStyle = alignedAxisRenderColor;
          ctx.lineWidth = alignedAxisThicknessFactor / PPM;
          ctx.beginPath();
          ctx.moveTo(-axisAlignedLength, 0);
          ctx.lineTo(axisAlignedLength, 0);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, -axisAlignedLength);
          ctx.lineTo(0, axisAlignedLength);
          ctx.stroke();
          ctx.lineWidth = orientedAxisThicknessFactor / PPM;
          ctx.strokeStyle = rotationAngleArcColor;
          ctx.beginPath();
          ctx.arc(0, 0, rotationAngleArcRadiusFactor * length, rotOffset, rot + rotOffset, rot < 0);
          ctx.stroke();
          ctx.rotate(rot);
          const orientedAxisLength = orientedAxisScaleFactor * length;
          ctx.strokeStyle = orientedAxisRenderColor;
          ctx.beginPath();
          ctx.moveTo(-orientedAxisLength, 0);
          ctx.lineTo(orientedAxisLength, 0);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, -orientedAxisLength);
          ctx.lineTo(0, orientedAxisLength);
          ctx.stroke();
          ctx.restore();
        }
      };
    }
  });

  // src/systems/render/debug/ChunkBorderRenderSystem.ts
  var schema17, meta, lineWidth, color, ChunkBorderRenderSystem;
  var init_ChunkBorderRenderSystem = __esm({
    "src/systems/render/debug/ChunkBorderRenderSystem.ts"() {
      init_dist();
      init_internal();
      init_dist();
      init_ChunkComponent();
      schema17 = {
        chunk: Chunk
      };
      meta = fluidInternal.registerNodeSchema(schema17, "Chunk");
      lineWidth = 1 / 1e3;
      color = "red";
      ChunkBorderRenderSystem = class extends FluidSystem {
        constructor(clientContext) {
          super("Chunk Border Render System", meta);
          this.clientContext = clientContext;
        }
        updateNode(node) {
          const clientContext = this.clientContext;
          if (!clientContext.displayChunks)
            return;
          const ctx = this.clientContext.renderer.renderContext;
          const chunk = node.chunk.chunk;
          if (chunk.state !== ChunkState.Loaded) return;
          const { index, size } = chunk;
          const corner = getChunkCornerFromIndex(index[0], index[1], size);
          ctx.save();
          ctx.translate(corner.x, corner.y);
          ctx.lineWidth = lineWidth * 4 / 3;
          ctx.strokeStyle = "white";
          ctx.strokeRect(0, 0, size, size);
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = color;
          ctx.strokeRect(0, 0, size, size);
          ctx.restore();
        }
      };
    }
  });

  // src/systems/index.ts
  var init_systems = __esm({
    "src/systems/index.ts"() {
      init_CursorSystem();
      init_FiringSystem();
      init_KinematicSystem();
      init_MovementControlSystem();
      init_PositionSystem();
      init_CollisionDetectionSystem();
      init_ViewportSystem();
      init_ProjectileSystem();
      init_BoundingBoxUpdateSystem();
      init_chunk();
      init_WorldPreRenderSystem();
      init_ViewportRenderSystem();
      init_DebugInfoDisplaySystem();
      init_SpriteRenderSystem();
      init_BoundingBoxRenderSystem();
      init_AxisRenderSystem();
      init_ChunkBorderRenderSystem();
    }
  });

  // src/systems/render/debug/OccupiedChunkHighlightingSystem.ts
  var schema18, nodeMeta19, generalHighlightColor, renderCenterHighlightColor, generalHighlightAlpha, renderCenterHighlightAlpha, OccupiedChunkHighlightingSystem;
  var init_OccupiedChunkHighlightingSystem = __esm({
    "src/systems/render/debug/OccupiedChunkHighlightingSystem.ts"() {
      init_dist();
      init_internal();
      init_dist();
      init_ChunkOccupancyComponent();
      init_RenderCenterComponent();
      schema18 = {
        chunks: ChunkOccupancy
      };
      nodeMeta19 = fluidInternal.registerNodeSchema(schema18, "Occupied Chunk Highlighting");
      generalHighlightColor = "blue";
      renderCenterHighlightColor = "red";
      generalHighlightAlpha = 0.05;
      renderCenterHighlightAlpha = 0.35;
      OccupiedChunkHighlightingSystem = class extends FluidSystem {
        constructor(clientContext) {
          super("Occupied Chunk Highlighting System", nodeMeta19);
          this.clientContext = clientContext;
        }
        updateNode(node) {
          const clientContext = this.clientContext;
          if (!clientContext.displayChunks)
            return;
          const worldContext = clientContext.worldContext, ctx = clientContext.renderer.renderContext;
          const chunkSize = worldContext.chunkSize;
          const proxy = fluidInternal.getEntityProxy(node.entityId);
          const isRenderCenter = proxy.hasComponent(RenderCenter);
          ctx.save();
          if (isRenderCenter) {
            ctx.globalAlpha = renderCenterHighlightAlpha;
            ctx.fillStyle = renderCenterHighlightColor;
          } else {
            ctx.globalAlpha = generalHighlightAlpha;
            ctx.fillStyle = generalHighlightColor;
          }
          for (let chunkKey of node.chunks.chunkKeys) {
            const index = parseChunkKey(chunkKey);
            const corner = getChunkCornerFromIndex(index[0], index[1], chunkSize);
            ctx.fillRect(corner.x, corner.y, chunkSize, chunkSize);
          }
          ctx.restore();
        }
      };
    }
  });

  // src/world/Scene.ts
  var ReloadableEntityImpl, SceneFacade;
  var init_Scene = __esm({
    "src/world/Scene.ts"() {
      init_dist();
      ReloadableEntityImpl = class {
        constructor(entityId, components = []) {
          this.entityId = entityId;
          this.components = components;
        }
        load() {
          const entityId = this.entityId;
          const core = fluidInternal.core();
          const entityManager = core.getEntityManager();
          const componentRepo = core.getComponentManager().getComponentRepository();
          if (entityManager.hasEntity(entityId))
            return false;
          entityManager.addEntity(entityId);
          if (this.components.length > 0) {
            for (const component of this.components) {
              componentRepo.addComponent(component, entityId);
            }
          }
          return true;
        }
        unload() {
          const entityId = this.entityId;
          const core = fluidInternal.core();
          if (core.getEntityManager().hasEntity(entityId)) {
            this.components = Array.from(core.getComponentManager().getComponentRepository().getEntityComponents(entityId));
            fluidInternal.removeEntity(entityId);
            return true;
          }
          return false;
        }
      };
      SceneFacade = class {
        static entityMap = /* @__PURE__ */ new Map();
        static unloadEntity(entityId) {
          const entitySymbol = entityId.getSymbol();
          let rEntity = this.entityMap.get(entitySymbol);
          if (!rEntity) {
            rEntity = new ReloadableEntityImpl(entityId, []);
            this.entityMap.set(entitySymbol, rEntity);
          }
          rEntity.unload();
          return rEntity;
        }
        static loadEntity(entitySymbol) {
          const rEntity = this.entityMap.get(entitySymbol);
          return rEntity ? rEntity.load() : false;
        }
      };
    }
  });

  // src/animation/Interpolators.ts
  function registerInterpolation(interpolator, name) {
    const id = new AInterpolationId(name);
    AInterpolationId.map.set(id.getSymbol(), interpolator);
    return id;
  }
  function resolveInterpolator(interpolationId) {
    return AInterpolationId.map.get(interpolationId.getSymbol());
  }
  var AInterpolationId, InterpolationRegistry, transformScaleLerpId;
  var init_Interpolators = __esm({
    "src/animation/Interpolators.ts"() {
      init_Utils();
      AInterpolationId = class _AInterpolationId {
        static map = /* @__PURE__ */ new Map();
        static nextId = 0;
        idNumber;
        idSymbol;
        name;
        constructor(name) {
          this.idNumber = _AInterpolationId.nextId++;
          this.name = `Interpolation#${this.idNumber}(${name})`;
          this.idSymbol = Symbol(this.name);
        }
        getSymbol() {
          return this.idSymbol;
        }
        getName() {
          return this.name;
        }
        getNumericId() {
          return this.idNumber;
        }
      };
      InterpolationRegistry = { registerInterpolation, resolveInterpolator };
      transformScaleLerpId = InterpolationRegistry.registerInterpolation(transformScaleLerpBulge, "LERP(transform.scale)");
    }
  });

  // src/components/AsteroidComponent.ts
  var Asteroid;
  var init_AsteroidComponent = __esm({
    "src/components/AsteroidComponent.ts"() {
      init_dist();
      Asteroid = fluidInternal.defineComponentType("Asteroid");
    }
  });

  // src/components/HealthComponent.ts
  var Health;
  var init_HealthComponent = __esm({
    "src/components/HealthComponent.ts"() {
      init_dist();
      Health = fluidInternal.defineComponentType("Health");
    }
  });

  // src/components/PropertyAnimationComponent.ts
  function createPropertyAnimationsComponent(entries) {
    const map = /* @__PURE__ */ new Map();
    for (const [componentType, animationsData] of entries) {
      for (const animationData of animationsData) {
        const componentTypeSymbol = componentType.getId().getSymbol();
        let innerMap = map.get(componentTypeSymbol);
        if (!innerMap) {
          innerMap = /* @__PURE__ */ new Map();
          map.set(componentTypeSymbol, innerMap);
        }
        innerMap.set(animationData.propertyName, { componentType, ...animationData });
      }
    }
    return PropertyAnimation.createComponent({ animations: map });
  }
  var PropertyAnimation;
  var init_PropertyAnimationComponent = __esm({
    "src/components/PropertyAnimationComponent.ts"() {
      init_dist();
      PropertyAnimation = fluidInternal.defineComponentType("Property Animation");
    }
  });

  // src/components/LifetimeComponent.ts
  var LifeTime;
  var init_LifetimeComponent = __esm({
    "src/components/LifetimeComponent.ts"() {
      init_dist();
      LifeTime = fluidInternal.defineComponentType("Lifetime");
    }
  });

  // src/components/ParticleComponent.ts
  var Particle;
  var init_ParticleComponent = __esm({
    "src/components/ParticleComponent.ts"() {
      init_dist();
      Particle = fluidInternal.defineComponentType("Particle");
    }
  });

  // src/Sprites.ts
  function createSpriteEntity(position, rotation, spriteImageKey, zIndex, renderSize, transform) {
    return fluidInternal.createEntityWithComponents(
      Position.createComponent({
        position,
        rotation
      }),
      Sprite.createComponent({
        image: Assets_default.getSprite(spriteImageKey),
        zIndex,
        renderSize,
        transform
      })
    );
  }
  function renderSingleNeonLaserSprite({
    width: width2 = 256,
    height: height2 = 128,
    laserLength = 64,
    laserWidth = 16,
    color: color2 = "cyan"
  } = {}) {
    const canvas = document.createElement("canvas");
    canvas.width = width2;
    canvas.height = height2;
    const ctx = canvas.getContext("2d");
    const centerX = width2 / 2;
    const centerY = height2 / 2;
    ctx.clearRect(0, 0, width2, height2);
    ctx.save();
    ctx.translate(centerX, centerY);
    const gradient = ctx.createLinearGradient(-laserLength / 2, 0, laserLength / 2, 0);
    gradient.addColorStop(0, "transparent");
    gradient.addColorStop(0.3, color2);
    gradient.addColorStop(0.7, color2);
    gradient.addColorStop(1, "transparent");
    ctx.shadowBlur = 24;
    ctx.shadowColor = color2;
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.ellipse(0, 0, laserLength / 2, laserWidth / 2, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
    return canvas;
  }
  var canvasToImage2, loadImage2;
  var init_Sprites = __esm({
    "src/Sprites.ts"() {
      init_dist();
      init_dist();
      init_PositionComponent();
      init_SpriteComponent();
      init_Assets();
      canvasToImage2 = ImageUtils_exports.canvasToImage;
      loadImage2 = ImageUtils_exports.loadImage;
    }
  });

  // src/Assets.ts
  function loadImg(assetPath) {
    return ImageUtils_exports.loadImage(`${assetRoot}/${assetPath}`);
  }
  async function loadSprites() {
    const backgroundTileImage = await loadImg("background/space_background_tile.png");
    const asteroidImage = await loadImg("asteroid/asteroid1.png");
    const shipImage = await loadImg("ship/ship1.png");
    const laserShotCanvas = renderSingleNeonLaserSprite();
    const laserShotImage = ImageUtils_exports.canvasToImage(laserShotCanvas);
    const artilleryShellImage = await loadImg("projectile/shell2.png");
    return {
      backgroundTileImage,
      asteroidImage,
      shipImage,
      laserShotImage,
      artilleryShellImage
    };
  }
  var assetRoot, AssetRepository, Assets_default;
  var init_Assets = __esm({
    "src/Assets.ts"() {
      init_dist();
      init_Sprites();
      assetRoot = "/assets";
      AssetRepository = class {
        constructor(assets) {
          this.assets = assets;
        }
        async loadAssets() {
          const sprites = await loadSprites();
          this.assets = { sprites };
          return this.assets;
        }
        getAssets() {
          return this.assets;
        }
        getSprite(key) {
          return this.assets?.sprites?.[key];
        }
      };
      Assets_default = new AssetRepository(void 0);
    }
  });

  // src/Asteroids.ts
  function createAsteroid({
    position,
    rotation,
    velocity,
    angularVelocity,
    width: width2,
    options = {}
  }) {
    const {
      spriteImageKey = "asteroidImage",
      density = 3.2,
      health: optionalHealth,
      deriveHealth = (mass2, area2) => mass2 * area2,
      damageAnimationScalePercent = 1.11,
      damageAnimationDuration = 0.15
    } = options;
    const spriteImage = Assets_default.getSprite(spriteImageKey);
    const aspectRatio = spriteImage.height / spriteImage.width;
    const height2 = width2 * aspectRatio;
    const area = width2 * height2;
    const mass = density * area;
    const sizeTransform = { scale: 1 };
    const health = optionalHealth ? optionalHealth : deriveHealth(mass, area);
    const entity = createSpriteEntity(
      Vector2.copy(position),
      rotation,
      spriteImageKey,
      3,
      {
        x: width2,
        y: height2
      }
    );
    fluidInternal.addEntityComponents(
      entity,
      Asteroid.createComponent({ area }),
      Velocity.createComponent({
        velocity,
        angular: angularVelocity
      }),
      Physics.createComponent({
        mass,
        centerOfMassOffset: Vector2.zero(),
        area: width2 * height2,
        momentOfInertia: calculateRectangleMomentOfInertia(mass, width2, height2)
      }),
      ChunkOccupancy.createComponent({ chunkKeys: /* @__PURE__ */ new Set() }),
      BoundingBox.createComponent(createBoundingBox({ width: width2, height: height2 })),
      Health.createComponent({ maxHealth: health, currentHealth: health, visible: true }),
      createPropertyAnimationsComponent(
        [
          [
            // Sprite animations
            Sprite,
            [
              // damaged animation
              {
                propertyName: "transform",
                beginningValue: sizeTransform,
                endingValue: { scale: damageAnimationScalePercent },
                completed: true,
                duration: damageAnimationDuration,
                elapsed: 0,
                onComplete(entityId, propertyAnimationComponent) {
                  const transform = propertyAnimationComponent.animations.get(Sprite.getId().getSymbol()).get("transform");
                  transform.completed = true;
                },
                interpolationId: transformScaleLerpId
              }
            ]
          ]
        ]
      )
    );
    return entity;
  }
  function createAsteroidParticle(position, velocity, rotation, angularVelocity, spawnTime, lifeTime, size) {
    const entityId = createSpriteEntity(
      position,
      rotation,
      "asteroidImage",
      3,
      { x: size, y: size }
    );
    fluidInternal.addEntityComponents(
      entityId,
      Velocity.createComponent({ velocity, angular: angularVelocity }),
      LifeTime.createComponent({ lifeDuration: lifeTime, spawnTime }),
      Particle.createComponent({})
    );
    return entityId;
  }
  var init_Asteroids = __esm({
    "src/Asteroids.ts"() {
      init_dist();
      init_dist();
      init_Interpolators();
      init_AsteroidComponent();
      init_BoundingBoxComponent();
      init_ChunkOccupancyComponent();
      init_HealthComponent();
      init_PhysicsComponent();
      init_PropertyAnimationComponent();
      init_SpriteComponent();
      init_VelocityComponent();
      init_Utils();
      init_LifetimeComponent();
      init_ParticleComponent();
      init_Assets();
      init_Sprites();
    }
  });

  // src/world/World.ts
  function generateChunk(worldContext, chunkIndex, chunkSize, engine) {
    const chunkCenter = getChunkCenterFromIndex(chunkIndex[0], chunkIndex[1], chunkSize);
    let chunkEntity = createSpriteEntity(
      chunkCenter,
      0,
      "backgroundTileImage",
      0,
      {
        x: chunkSize,
        y: chunkSize
      }
    );
    const halfChunkSize = chunkSize / 2;
    const nSubDivision = 3;
    const subGridSize = chunkSize / 3;
    const asteroidProbability = 0.3, sgap = asteroidProbability / (nSubDivision * nSubDivision);
    const minVelocity = 0.08, maxVelocity = 0.32, maxAngularVelocity = 1.2;
    const minSize = 0.08, maxSize = 0.4;
    const minDensity = 1, maxDensity = 2.2;
    for (let i = 0; i < nSubDivision; i++)
      for (let j = 0; j < nSubDivision; j++) {
        if (Math.random() > sgap)
          continue;
        let x = chunkCenter.x - halfChunkSize + i * subGridSize;
        let y = chunkCenter.y - halfChunkSize + j * subGridSize;
        let asteroidPosition = {
          x: boundedRandom(x, x + subGridSize),
          y: boundedRandom(y, y + subGridSize)
        };
        let asteroidRotation = Math.random() * 2 * Math.PI;
        let asteroidVelocity = Vector2.scale(
          Vector2.normalize(
            {
              x: Math.random() - 0.5,
              y: Math.random() - 0.5
            }
          ),
          boundedRandom(minVelocity, maxVelocity)
        );
        const angularVelocity = boundedRandom(minVelocity, maxAngularVelocity);
        const size = boundedRandom(minSize, maxSize);
        const density = boundedRandom(minDensity, maxDensity);
        createAsteroid({
          position: asteroidPosition,
          velocity: asteroidVelocity,
          rotation: asteroidRotation,
          angularVelocity,
          width: size,
          options: {
            density
          }
        });
      }
    const chunkMeta = createChunk(
      chunkIndex,
      chunkSize,
      ChunkState.Loaded,
      {
        entitySymbolSet: /* @__PURE__ */ new Set([chunkEntity.getSymbol()]),
        lastAccessed: engine.getGameTime()
      }
    );
    const chunkComponent = Chunk.createComponent({ chunk: chunkMeta }, false);
    fluidInternal.addEntityComponent(chunkEntity, chunkComponent);
    return chunkMeta;
  }
  var WorldContext;
  var init_World = __esm({
    "src/world/World.ts"() {
      init_dist();
      init_dist();
      init_Scene();
      init_dist();
      init_MathUtils();
      init_Asteroids();
      init_ChunkComponent();
      init_Sprites();
      WorldContext = class {
        // private unloadedEntitiesChunkMap = new Map<ChunkKey, Entity[]>();
        constructor(engineInstance, chunkSize, chunkTimeout, generateChunk2) {
          this.engineInstance = engineInstance;
          this.chunkSize = chunkSize;
          this.chunkTimeout = chunkTimeout;
          this.generateChunk = generateChunk2;
        }
        chunkMap = /* @__PURE__ */ new Map();
        getChunk(key) {
          return this.chunkMap.get(key);
        }
        setChunk(key, chunk) {
          this.chunkMap.set(key, chunk);
        }
        loadChunk(key) {
          let chunk = this.chunkMap.get(key);
          if (!chunk) {
            chunk = this.generateChunk(this, parseChunkKey(key), this.chunkSize);
            this.setChunk(key, chunk);
          } else {
            if (chunk.state === ChunkState.Loaded) {
              throw new Error(`Chunk is already loaded (chunk: ${key})`);
            }
            for (const entitySymbol of chunk.entitySymbolSet) {
              SceneFacade.loadEntity(entitySymbol);
            }
          }
          chunk.state = ChunkState.Loaded;
          return chunk;
        }
        unloadEntity(entityID, chunkKey) {
          SceneFacade.unloadEntity(entityID);
        }
        unloadChunk(key) {
          let chunk = this.chunkMap.get(key);
          if (!chunk) throw new Error(`Chunk is undefined (key: ${key})`);
          if (chunk.state === ChunkState.Unloaded) throw new Error(`Chunk is already unloaded (chunk: ${key})`);
          const entityResolver = fluidInternal.core().getEntityManager().getEntityResolver();
          for (const entitySymbol of chunk.entitySymbolSet) {
            const entityId = entityResolver.getEntityBySymbol(entitySymbol);
            if (entityId)
              SceneFacade.unloadEntity(entityId);
          }
          chunk.state = ChunkState.Unloaded;
          return true;
        }
        getAllChunks() {
          return Array.from(this.chunkMap.values());
        }
      };
    }
  });

  // src/systems/render/HealthBarRenderSystem.ts
  function interpolateRGB(rgb1, rgb2, percent) {
    const result = [0, 0, 0];
    for (let i = 0; i < 3; i++) {
      result[i] = MathUtils_exports.lerp(rgb1[i], rgb2[i], percent);
    }
    return result;
  }
  var schema19, meta2, width, height, hw, hh, outlineThickness, owidth, oheight, ohw, ohh, yDist, bkg, highColorRGB, lowColorRGB, healthColorGradient, gradientSteps, hPI3, HealthBarRenderSystem;
  var init_HealthBarRenderSystem = __esm({
    "src/systems/render/HealthBarRenderSystem.ts"() {
      init_dist();
      init_internal();
      init_HealthComponent();
      init_PositionComponent();
      init_dist();
      schema19 = {
        position: Position,
        health: Health
      };
      meta2 = fluidInternal.registerNodeSchema(schema19, "Health Render");
      width = 0.2;
      height = 0.01;
      hw = width / 2;
      hh = height / 2;
      outlineThickness = 5e-3;
      owidth = width + outlineThickness;
      oheight = height + outlineThickness;
      ohw = owidth / 2;
      ohh = oheight / 2;
      yDist = 0.13;
      bkg = "white";
      highColorRGB = [5, 240, 25];
      lowColorRGB = [240, 5, 5];
      healthColorGradient = [];
      gradientSteps = 255;
      for (let step = 0; step <= gradientSteps; step++) {
        healthColorGradient[step] = `rgb(${interpolateRGB(lowColorRGB, highColorRGB, step / gradientSteps).join(",")})`;
      }
      hPI3 = Math.PI / 2;
      HealthBarRenderSystem = class extends FluidSystem {
        constructor(renderContext, getViewportRotation) {
          super("Health Bar Render System", meta2);
          this.renderContext = renderContext;
          this.getViewportRotation = getViewportRotation;
        }
        updateNode(node) {
          const ctx = this.renderContext;
          const { position, health } = node;
          if (!health.visible)
            return;
          const { x, y } = position.position;
          const { currentHealth, maxHealth } = health;
          const healthPercent = currentHealth / maxHealth;
          const fillWidth = healthPercent * width;
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(this.getViewportRotation() + hPI3);
          ctx.translate(0, yDist);
          ctx.fillStyle = bkg;
          ctx.fillRect(-ohw, -ohh, owidth, oheight);
          ctx.fillStyle = healthColorGradient[Math.floor(healthPercent * (healthColorGradient.length - 1))];
          ctx.fillRect(-hw, -hh, fillWidth, height);
          ctx.restore();
        }
      };
    }
  });

  // src/components/EntityDeathComponent.ts
  var EntityDeath;
  var init_EntityDeathComponent = __esm({
    "src/components/EntityDeathComponent.ts"() {
      init_dist();
      EntityDeath = fluidInternal.defineComponentType("Entity Death");
    }
  });

  // src/systems/simulation/AsteroidDeathSystem.ts
  var schema20, nodeMeta20, explosionIntensityScale, AsteroidDeathSystem;
  var init_AsteroidDeathSystem = __esm({
    "src/systems/simulation/AsteroidDeathSystem.ts"() {
      init_dist();
      init_internal();
      init_dist();
      init_AsteroidComponent();
      init_EntityDeathComponent();
      init_PositionComponent();
      init_VelocityComponent();
      init_Asteroids();
      schema20 = {
        asteroid: Asteroid,
        position: Position,
        velocity: Velocity,
        entityDeath: EntityDeath
      };
      nodeMeta20 = fluidInternal.registerNodeSchema(schema20, "Asteroid Death");
      explosionIntensityScale = 0.1;
      AsteroidDeathSystem = class extends FluidSystem {
        constructor(clientContext) {
          super("Asteroid Death System", nodeMeta20);
          this.clientContext = clientContext;
        }
        updateNode(node) {
          const {
            asteroid,
            position,
            velocity,
            entityDeath,
            entityId
          } = node;
          const { area } = asteroid;
          const count = area * 10 * 5;
          const increment = 2 * Math.PI / count;
          if (entityDeath.readyToRemove) {
            fluidInternal.removeEntity(entityId);
            return;
          }
          for (let angle = 0; angle < 2 * Math.PI; angle += increment) {
            let vX = Math.cos(angle) * (0.5 + 0.65 * Math.random());
            let vY = Math.sin(angle) * (0.5 + 0.65 * Math.random());
            createAsteroidParticle(
              Vector2.copy(position.position),
              Vector2.add(velocity.velocity, Vector2.scale({ x: vX, y: vY }, explosionIntensityScale)),
              position.rotation + angle,
              velocity.angular + 1.2 * Math.PI * Math.random(),
              this.clientContext.engineInstance.getGameTime(),
              5,
              Math.sqrt((0.3 + 0.7 * Math.random() / count) * asteroid.area)
            );
          }
          entityDeath.readyToRemove = true;
        }
      };
    }
  });

  // src/systems/simulation/ParticleSystem.ts
  var schema21, nodeMeta21, ParticleSystem;
  var init_ParticleSystem = __esm({
    "src/systems/simulation/ParticleSystem.ts"() {
      init_dist();
      init_internal();
      init_LifetimeComponent();
      init_ParticleComponent();
      schema21 = {
        particle: Particle,
        lifetime: LifeTime
      };
      nodeMeta21 = fluidInternal.registerNodeSchema(schema21, "Particle Render System");
      ParticleSystem = class extends FluidSystem {
        constructor(clientContext) {
          super("Particle Render System", nodeMeta21);
          this.clientContext = clientContext;
        }
        updateNode(node) {
          const gameTime = this.clientContext.engineInstance.getGameTime();
          const { entityId, lifetime } = node;
          let { lifeDuration, spawnTime } = lifetime;
          if (spawnTime <= 0)
            spawnTime = gameTime;
          const deathTime = spawnTime + lifeDuration;
          if (gameTime >= deathTime)
            fluidInternal.removeEntity(entityId);
        }
      };
    }
  });

  // src/systems/simulation/ProjectileDamageSystem.ts
  var schema22, nodeMeta22, ProjectileDamageSystem;
  var init_ProjectileDamageSystem = __esm({
    "src/systems/simulation/ProjectileDamageSystem.ts"() {
      init_dist();
      init_internal();
      init_CollisionComponent();
      init_EntityDeathComponent();
      init_HealthComponent();
      init_ProjectileComponent();
      init_AsteroidComponent();
      init_PropertyAnimationComponent();
      init_SpriteComponent();
      schema22 = {
        projectile: Projectile,
        collision: Collision
      };
      nodeMeta22 = fluidInternal.registerNodeSchema(schema22, "Projectile Damage");
      ProjectileDamageSystem = class extends FluidSystem {
        constructor() {
          super("Projectile Damage System", nodeMeta22);
        }
        updateNode(node) {
          const { collision, entityId: projectileEntityId, projectile: projectileData } = node;
          const otherEntity = fluidInternal.getEntityProxy(collision.collidedEntity);
          if (!otherEntity.hasComponent(Health))
            return;
          const healthData = otherEntity.getComponent(Health).data;
          const health = Math.max(0, healthData.currentHealth - projectileData.damage);
          healthData.currentHealth = health;
          if (otherEntity.hasComponent(Asteroid) && otherEntity.hasComponent(PropertyAnimation)) {
            const animations = otherEntity.getComponent(PropertyAnimation).data.animations;
            const anim = animations.get(Sprite.getId().getSymbol())?.get("transform");
            if (anim) {
              if (anim.completed) {
                anim.elapsed = 0;
                anim.completed = false;
              }
            }
          }
          if (health === 0) {
            if (!otherEntity.hasComponent(EntityDeath))
              otherEntity.addComponent(EntityDeath.createComponent({ readyToRemove: false }));
          }
          fluidInternal.removeEntity(projectileEntityId);
          otherEntity.removeComponent(Collision);
        }
      };
    }
  });

  // src/systems/simulation/animation/PropertyAnimationSystem.ts
  var schema23, nodeMeta23, PropertyAnimationSystem;
  var init_PropertyAnimationSystem = __esm({
    "src/systems/simulation/animation/PropertyAnimationSystem.ts"() {
      init_internal();
      init_PropertyAnimationComponent();
      init_dist();
      schema23 = {
        propertyAnimation: PropertyAnimation
      };
      nodeMeta23 = fluidInternal.registerNodeSchema(schema23, "Property Animation Node");
      PropertyAnimationSystem = class extends FluidSystem {
        constructor(engineInstance, resolveInterpolator2) {
          super("Property Animation System", nodeMeta23);
          this.engineInstance = engineInstance;
          this.resolveInterpolator = resolveInterpolator2;
        }
        updateNode(node) {
          const { propertyAnimation, entityId } = node;
          const deltaTime = this.engineInstance.getDeltaTime();
          for (const [componentTypeSymbol, animationMap] of propertyAnimation.animations.entries())
            for (const [propertyName, animation] of animationMap.entries()) {
              const { componentType, duration, elapsed, beginningValue, interpolationId, propertyName: propertyName2, endingValue, loop, onComplete } = animation;
              if (animation.completed || !fluidInternal.entityHasComponent(entityId, componentType))
                continue;
              animation.elapsed += deltaTime;
              const interpolator = this.resolveInterpolator(interpolationId);
              const clampedElapsed = Math.min(elapsed, duration);
              const nextValue = interpolator(beginningValue, endingValue, clampedElapsed, duration);
              const component = fluidInternal.getEntityComponent(entityId, componentType);
              component.data[propertyName2] = nextValue;
              if (elapsed >= duration) {
                if (loop) {
                  animation.elapsed = 0;
                } else {
                  animation.completed = true;
                  onComplete?.(entityId, propertyAnimation);
                }
              }
            }
        }
      };
    }
  });

  // src/Projectiles.ts
  function spawnProjectile({
    position,
    velocity,
    rotation,
    angularVelocity,
    generation,
    width: width2,
    type,
    spawnTime,
    options = {}
  }) {
    const {
      damage,
      density,
      spriteImageKey,
      lifeTime
    } = type;
    const {} = options;
    const spriteImage = Assets_default.getSprite(spriteImageKey);
    const imageAspectRatio = spriteImage.height / spriteImage.width;
    const height2 = width2 * imageAspectRatio;
    const area = width2 * height2;
    const mass = density * area;
    const deathTime = spawnTime + lifeTime;
    const entity = createSpriteEntity(
      position,
      rotation,
      spriteImageKey,
      0,
      {
        x: width2,
        y: height2
      }
    );
    fluidInternal.addEntityComponents(
      entity,
      Projectile.createComponent({
        deathTime,
        generation,
        damage
      }),
      Velocity.createComponent({
        velocity,
        angular: angularVelocity
      }),
      Acceleration.createComponent({
        acceleration: { x: 0, y: 0 },
        angular: 0
      }),
      Physics.createComponent({
        mass,
        centerOfMassOffset: Vector2.zero(),
        area,
        momentOfInertia: calculateRectangleMomentOfInertia(mass, width2, height2)
      }),
      BoundingBox.createComponent(
        createBoundingBox(
          {
            width: width2,
            height: height2
          },
          { transform: { scale: 0.98 } }
          // smaller bounding box for tighter collision tolerance
        )
      ),
      ChunkOccupancy.createComponent({ chunkKeys: /* @__PURE__ */ new Set() })
    );
    return entity;
  }
  var init_Projectiles = __esm({
    "src/Projectiles.ts"() {
      init_dist();
      init_dist();
      init_AccelerationComponent();
      init_BoundingBoxComponent();
      init_ChunkOccupancyComponent();
      init_PhysicsComponent();
      init_ProjectileComponent();
      init_VelocityComponent();
      init_Utils();
      init_Sprites();
      init_Assets();
    }
  });

  // src/Overlays.ts
  function drawPauseScreen(renderContext, renderer) {
    renderContext.save();
    renderContext.globalAlpha = 0.5;
    renderer.clear();
    renderContext.globalAlpha = 0.5;
    renderContext.font = "bold 256px calibri";
    renderContext.fillStyle = "white";
    renderContext.fillText("\u23F8", (renderer.getWidth() - 256) / 2, renderer.getHeight() / 2);
    renderContext.restore();
  }
  function drawControlGuide(controlBinder, renderContext, renderer) {
    renderContext.save();
    renderContext.globalAlpha = 1;
    renderContext.font = "16px calibri";
    renderContext.fillStyle = "white";
    renderContext.textAlign = "left";
    const bindings = controlBinder.getBindings().filter((b) => b.name && b.keys.length > 0 && b.enabled);
    const keysString = (keys) => `[ ${keys.map((k) => `'${k.toUpperCase()}'`).join(" / ")} ]`;
    const textLines = bindings.map(
      (b) => `${keysString(b.keys)}				 ${b.name}${b.continuous ? " (hold)" : ""}${b.description ? ` :${b.description}` : ""}
`
    );
    const textPairing = textLines.map((line) => [line, "white"]);
    drawComplexText(renderContext, 10, 20, textPairing, 4);
    drawComplexText(renderContext, 10, 10, [["test", "white"]], 4);
    renderContext.restore();
  }
  var init_Overlays = __esm({
    "src/Overlays.ts"() {
      init_Utils();
    }
  });

  // src/ControlBindings.ts
  function mouseButtonToString(button) {
    return `mouse${button}`;
  }
  function createControlBinding(controlBindingProperties = {
    keys: [],
    action: () => {
    }
  }) {
    return new ControlBinding(controlBindingProperties);
  }
  function createDefaultControlBindings(engine, clientContext, movementControlComponent, fireControlComponent) {
    return {
      // Movement controls
      up: createControlBinding({
        name: "Move Up",
        keys: ["w"],
        action: () => {
          movementControlComponent.data.accelerationInput.y += 1;
        },
        continuous: true
      }),
      down: createControlBinding({
        name: "Move Down",
        keys: ["s"],
        action: () => {
          movementControlComponent.data.accelerationInput.y += -1;
        },
        continuous: true
      }),
      left: createControlBinding({
        name: "Move Left",
        keys: ["a"],
        action: () => {
          movementControlComponent.data.accelerationInput.x += -1;
        },
        continuous: true
      }),
      right: createControlBinding({
        name: "Move Right",
        keys: ["d"],
        action: () => {
          movementControlComponent.data.accelerationInput.x += 1;
        },
        continuous: true
      }),
      yawLeft: createControlBinding({
        name: "Yaw Left",
        keys: ["q"],
        action: () => {
          movementControlComponent.data.yawInput -= 1;
        },
        continuous: true
      }),
      yawRight: createControlBinding({
        name: "Yaw Right",
        keys: ["e"],
        action: () => {
          movementControlComponent.data.yawInput += 1;
        },
        continuous: true
      }),
      // Fire control
      fire_keyboard: createControlBinding({
        name: "Fire",
        keys: [" ", mouseButtonToString(0)],
        action: () => {
          fireControlComponent.data.fireIntent = true;
        },
        continuous: true
      }),
      // Hotkeys
      pause: createControlBinding({
        name: "Pause",
        keys: ["escape"],
        action: () => {
          engine.toggleAnimation();
        }
      }),
      eagle_eye_zoom: createControlBinding({
        name: "Eagle Eye Zoom",
        keys: ["v"],
        action: () => clientContext.setZoomLevel(5)
      }),
      reset_zoom: createControlBinding({
        name: "Reset Zoom",
        keys: ["x"],
        action: () => clientContext.setZoomLevel(30)
      }),
      decrease_zoom: createControlBinding({
        name: "Decrease Zoom",
        keys: ["z"],
        action: () => {
          const decrement = 10;
          const max = 100;
          const min = decrement;
          const next = clientContext.getZoomLevel() - decrement;
          clientContext.setZoomLevel(next < min ? max : next);
        }
      }),
      increase_zoom: createControlBinding({
        name: "Increase Zoom",
        keys: ["c"],
        action: () => {
          const increment = 10;
          const max = 100;
          const min = increment;
          const next = clientContext.getZoomLevel() + increment;
          clientContext.setZoomLevel(next > max ? min : next);
        }
      }),
      slow_time: createControlBinding({
        name: "Slow Time",
        keys: ["["],
        action: () => clientContext.setSimulationSpeed(clientContext.getSimulationSpeed() / 2)
      }),
      speed_time: createControlBinding({
        name: "Speed Time",
        keys: ["]"],
        action: () => clientContext.setSimulationSpeed(clientContext.getSimulationSpeed() * 2)
      }),
      reset_simulation_speed: createControlBinding({
        name: "Reset Simulation Speed",
        keys: ["-"],
        action: () => clientContext.setSimulationSpeed(1)
      }),
      toggle_debug_info: createControlBinding({
        name: "Toggle Debug Info",
        keys: ["f1"],
        action: () => {
          clientContext.displayDebugInfo = !clientContext.displayDebugInfo;
        }
      }),
      toggle_colliders: createControlBinding({
        name: "Toggle Colliders",
        keys: ["f2"],
        action: () => {
          clientContext.displayBoundingBoxes = !clientContext.displayBoundingBoxes;
        }
      }),
      toggle_display_axes: createControlBinding({
        name: "Toggle Display Axes",
        keys: ["f3"],
        action: () => {
          clientContext.displayEntityAxes = !clientContext.displayEntityAxes;
        }
      }),
      toggle_display_chunks: createControlBinding({
        name: "Toggle Display Chunks",
        keys: ["f4"],
        action: () => {
          clientContext.displayChunks = !clientContext.displayChunks;
        }
      })
    };
  }
  function registerDefaultBindings(controlBinder, engine, clientContext, movementControlComponent, fireControlComponent) {
    const bindings = createDefaultControlBindings(engine, clientContext, movementControlComponent, fireControlComponent);
    Object.values(bindings).forEach((binding) => {
      controlBinder.registerBinding(binding);
    });
    return controlBinder;
  }
  var ControlBinding, ControlBinder;
  var init_ControlBindings = __esm({
    "src/ControlBindings.ts"() {
      ControlBinding = class {
        constructor(controlBindingProperties = {
          keys: [],
          action: () => {
          }
        }) {
          this.controlBindingProperties = controlBindingProperties;
          this.name = controlBindingProperties.name || "Unnamed Control Binding";
          this.description = controlBindingProperties.description || "";
          this.action = controlBindingProperties.action || (() => {
          });
          this.continuous = controlBindingProperties.continuous || false;
          this.enabled = controlBindingProperties.enabled !== void 0 ? controlBindingProperties.enabled : true;
          const keys = controlBindingProperties.keys || [];
          this.keys = keys.map((k) => k.toLowerCase());
        }
        name;
        description;
        keys;
        action;
        continuous;
        enabled;
      };
      ControlBinder = class {
        bindings = [];
        keyStates = /* @__PURE__ */ new Map();
        constructor() {
        }
        activateControlBindings(continuous) {
          for (const binding of this.bindings.filter((b) => b.continuous === continuous)) {
            if (!binding.enabled) continue;
            if (binding.keys.some((k) => this.keyStates.get(k))) {
              binding.action();
            }
          }
          return this;
        }
        registerBinding(binding) {
          this.bindings.push(binding);
          return this;
        }
        getBindings() {
          return this.bindings;
        }
        getActiveBindings() {
          return this.bindings.filter((b) => b.enabled && b.keys.some((k) => this.keyStates.get(k)));
        }
        setKeyState(key, pressed) {
          this.keyStates.set(key, pressed);
        }
        getKeyState(key) {
          return this.keyStates.get(key) || false;
        }
        clearKeyStates() {
          this.keyStates.clear();
          return this;
        }
        registerKeyboardListeners(element = window.document.body) {
          element.addEventListener("keydown", (event) => {
            event.preventDefault();
            this.setKeyState(event.key.toLowerCase(), true);
            this.activateControlBindings(false);
          });
          element.addEventListener("keyup", (event) => {
            this.setKeyState(event.key.toLowerCase(), false);
          });
          return this;
        }
        registerMouseListeners(element = window.document.body) {
          element.addEventListener("mousedown", (event) => {
            this.setKeyState(mouseButtonToString(event.button), true);
            this.activateControlBindings(false);
          });
          element.addEventListener("mouseup", (event) => {
            this.setKeyState(mouseButtonToString(event.button), false);
          });
          return this;
        }
        registerDefaultListeners() {
          this.registerKeyboardListeners();
          this.registerMouseListeners();
          return this;
        }
      };
    }
  });

  // src/AsteroidJourney.ts
  var AsteroidJourney_exports = {};
  __export(AsteroidJourney_exports, {
    start: () => start
  });
  async function start() {
    const maxVelocity = 2.5 * 2.99792458;
    const assetRepo = Assets_default;
    const assets = await assetRepo.loadAssets();
    const sprites = assets.sprites;
    const canvasElement = document.getElementById("canvas");
    canvasElement.addEventListener("contextmenu", function(e) {
      e.preventDefault();
    });
    const VIEWPORT_RESOLUTION_COMPONENT = Resolution.createComponent({
      resolution: Vector2.zero()
    });
    const renderContext = canvasElement.getContext("2d");
    const renderer = new CanvasRenderer(
      canvasElement,
      {
        scale: 0.98,
        renderBaseColor: "black",
        onresize: (pw, ph, nw, nh) => {
          VIEWPORT_RESOLUTION_COMPONENT.data.resolution.x = nw;
          VIEWPORT_RESOLUTION_COMPONENT.data.resolution.y = nh;
        }
      }
    );
    let renderDistance = 5;
    const CAMERA = {
      position: Position.createComponent({
        position: {
          x: 0,
          y: 0
        },
        rotation: 0
      }),
      target: TargetPosition.createComponent({
        position: Position.createComponent({ position: Vector2.zero(), rotation: 0 }).data
      }),
      cameraSpeed: CameraSpeedFactor.createComponent({
        speedFactor: 22
      }),
      borderWidth: ViewportBorderWidth.createComponent({
        borderWidth: 0.05 * Math.min(renderer.getWidth(), renderer.getHeight())
      }),
      viewport: Viewport.createComponent({}),
      resolution: VIEWPORT_RESOLUTION_COMPONENT
    };
    const cameraEntityId = fluidInternal.createEntityWithComponents(
      ...Object.values(CAMERA)
    );
    const engine = new FluidEngine(fluidInternal.core(), 1024);
    const worldContext = new WorldContext(engine, 1.024, 0.1, (wC, cI, cS) => generateChunk(wC, cI, cS, engine));
    const clientContext = new ClientContext(engine, worldContext, renderer);
    clientContext.setZoomLevel(20);
    const MOVEMENT_CONTROL_COMPONENT = MovementControl.createComponent({
      accelerationInput: {
        x: 0,
        y: 0
      },
      yawInput: 0
    });
    const FIRE_CONTROL_COMPONENT = FireControl.createComponent({ fireIntent: false });
    const controlBinder = new ControlBinder().registerDefaultListeners();
    registerDefaultBindings(
      controlBinder,
      engine,
      clientContext,
      MOVEMENT_CONTROL_COMPONENT,
      FIRE_CONTROL_COMPONENT
    );
    const simulationPhase = new FluidSystemPhase(
      "Simulation Phase",
      () => {
        controlBinder.activateControlBindings(true);
      },
      () => {
        MOVEMENT_CONTROL_COMPONENT.data.yawInput = 0;
        MOVEMENT_CONTROL_COMPONENT.data.accelerationInput.x = 0;
        MOVEMENT_CONTROL_COMPONENT.data.accelerationInput.y = 0;
        FIRE_CONTROL_COMPONENT.data.fireIntent = false;
      }
    );
    const worldRenderPhase = new FluidSystemPhase(
      "World Render Phase",
      () => {
      },
      () => {
        renderContext.restore();
      }
    );
    const hudRenderPhase = new FluidSystemPhase(
      "Hud Render Phase",
      () => {
      },
      () => {
        if (!engine.getAnimationState()) {
          drawPauseScreen(renderContext, renderer);
          drawControlGuide(controlBinder, renderContext, renderer);
        }
      }
    );
    const sysman = fluidInternal.core().getSystemOrchestrator();
    sysman.pushPhases(simulationPhase, worldRenderPhase, hudRenderPhase);
    let kinematicSystem = new KinematicSystem(clientContext), positionSystem = new PositionSystem(engine), movementControlSystem = new MovementControlSystem(() => engine.getDeltaTime()), viewportSystem = new ViewportSystem(clientContext), projectileSystem = new ProjectileSystem(engine), firingSystem = new FiringSystem(engine, spawnProjectile), cursorSystem = new CursorSystem(engine), chunkLoadingSystem = new ChunkLoadingSystem(engine, worldContext), chunkUnloadingSystem = new ChunkUnloadingSystem(engine, worldContext), chunkOccupancyUpdateSystem = new ChunkOccupancyUpdateSystem(engine, worldContext), boundingBoxUpdateSystem = new BoundingBoxUpdateSystem(), collisionDetectionSystem = new CollisionDetectionSystem(engine), pojectileDamageSystem = new ProjectileDamageSystem(), worldPreRenderSystem = new WorldPreRenderSystem(clientContext), viewportRenderSystem = new ViewportRenderSystem(renderContext), debugInfoDisplaySystem = new DebugInfoDisplaySystem(clientContext), spriteRenderSystem = new SpriteRenderSystem(renderer), boundingBoxRenderSystem = new BoundingBoxRenderSystem(clientContext), axisRenderSystem = new AxisRenderSystem(clientContext), chunkBorderRenderSystem = new ChunkBorderRenderSystem(clientContext), occupiedChunkHighlightingSystem = new OccupiedChunkHighlightingSystem(clientContext), healthBarRenderSystem = new HealthBarRenderSystem(renderContext, () => CAMERA.position.data.rotation);
    ;
    simulationPhase.pushSystems(
      chunkLoadingSystem,
      chunkOccupancyUpdateSystem,
      chunkUnloadingSystem,
      cursorSystem,
      firingSystem,
      projectileSystem,
      movementControlSystem,
      kinematicSystem,
      positionSystem,
      viewportSystem,
      boundingBoxUpdateSystem,
      collisionDetectionSystem,
      pojectileDamageSystem,
      new AsteroidDeathSystem(clientContext),
      new ParticleSystem(clientContext),
      new PropertyAnimationSystem(engine, InterpolationRegistry.resolveInterpolator)
    );
    worldRenderPhase.pushSystems(
      worldPreRenderSystem,
      spriteRenderSystem,
      occupiedChunkHighlightingSystem,
      chunkBorderRenderSystem,
      boundingBoxRenderSystem,
      axisRenderSystem,
      healthBarRenderSystem
    );
    hudRenderPhase.pushSystems(
      viewportRenderSystem,
      debugInfoDisplaySystem
    );
    const MC_POS = Position.createComponent({
      position: { x: 0, y: 0 },
      rotation: -Math.PI / 2
    });
    CAMERA.target.data.position = MC_POS.data;
    const artilleryShell = {
      lifeTime: 5,
      damage: 15e-4,
      density: 1.8,
      spriteImageKey: "artilleryShellImage"
    };
    function initMainCharacter() {
      const modelScaleFactor = 1 / 555;
      const shipImage = sprites.shipImage;
      const shipImageAspectRatio = shipImage.height / shipImage.width;
      const height2 = 0.2;
      const width2 = height2 / shipImageAspectRatio;
      const area = width2 * height2;
      const mass = 3e9 * modelScaleFactor;
      return fluidInternal.createEntityWithComponents(
        MC_POS,
        Velocity.createComponent(
          {
            velocity: { x: 0, y: 0 },
            angular: 0
          }
        ),
        Acceleration.createComponent(
          {
            acceleration: { x: 0, y: 0 },
            angular: 0
          }
        ),
        Stats.createComponent({}),
        ProjectileSource.createComponent({
          muzzleSpeed: 1.2 * 2.99792458,
          fireRate: 14,
          projectileWidth: 0.035,
          projectileType: artilleryShell,
          lastFireTime: 0,
          transform: {
            scale: height2 * 1.1 / 2
          }
        }),
        RenderCenter.createComponent({ renderDistance }),
        Sprite.createComponent(
          {
            image: shipImage,
            zIndex: 5,
            renderSize: { x: width2, y: height2 },
            transform: {
              rotate: Math.PI / 2
            }
          }
        ),
        BoundingBox.createComponent(
          createBoundingBox(
            {
              width: width2,
              height: height2
            },
            {
              transform: {
                rotate: Math.PI / 2
              }
            }
          )
        ),
        ChunkOccupancy.createComponent({ chunkKeys: /* @__PURE__ */ new Set() }),
        Physics.createComponent({
          mass,
          centerOfMassOffset: { x: 0, y: 0 },
          area,
          momentOfInertia: calculateRectangleMomentOfInertia(mass, width2, height2)
        }),
        Thruster.createComponent({ maxForce: 1.75 * 44e8 * modelScaleFactor }),
        MOVEMENT_CONTROL_COMPONENT,
        FIRE_CONTROL_COMPONENT,
        Health.createComponent({ maxHealth: 100, currentHealth: 60, visible: true })
      );
    }
    const MAIN_CHARACTER = initMainCharacter();
    const CURSOR_SCREEN_COMPONENT = ScreenPoint.createComponent({
      point: { x: 0, y: 0 }
    });
    canvasElement.addEventListener("mousemove", (event) => {
      CURSOR_SCREEN_COMPONENT.data.point = { x: event.offsetX, y: event.offsetY };
    });
    engine.animate();
    console.log("Asteroid Journey Started!");
  }
  var init_AsteroidJourney = __esm({
    "src/AsteroidJourney.ts"() {
      init_Client();
      init_Renderer();
      init_systems();
      init_OccupiedChunkHighlightingSystem();
      init_World();
      init_dist();
      init_internal();
      init_dist();
      init_HealthBarRenderSystem();
      init_AsteroidDeathSystem();
      init_ParticleSystem();
      init_ProjectileDamageSystem();
      init_Interpolators();
      init_PropertyAnimationSystem();
      init_Projectiles();
      init_Utils();
      init_SpriteComponent();
      init_RenderCenterComponent();
      init_StatsComponent();
      init_FireControlComponent();
      init_MovementControlComponent();
      init_ViewportBorderWidthComponent();
      init_CameraSpeedFactorComponent();
      init_ScreenPointComponent();
      init_AccelerationComponent();
      init_VelocityComponent();
      init_TargetPositionComponent();
      init_PositionComponent();
      init_ResolutionComponent();
      init_BoundingBoxComponent();
      init_ChunkOccupancyComponent();
      init_ProjectileSourceComponent();
      init_ViewportComponent();
      init_HealthComponent();
      init_ThrusterComponent();
      init_PhysicsComponent();
      init_Assets();
      init_Overlays();
      init_ControlBindings();
    }
  });

  // src/main.ts
  init_dist();
  async function main() {
    console.log(`Launcher has started!`);
    try {
      console.log("Bootstrapping Fluid Core...");
      const coreInstance = fluidInternal.bootstrap();
      console.log(`Fluid Core has been initialized!`, coreInstance);
    } catch (err) {
      console.error("Fluid Core initialization failed:", err);
      return;
    }
    try {
      console.log("Starting Asteroid Journey...");
      await Promise.resolve().then(() => (init_AsteroidJourney(), AsteroidJourney_exports)).then((m) => m.start());
    } catch (err) {
      console.error("Failed to load AsteroidJourney module:", err);
    }
  }
  main();
})();
